---
layout: post
title: "알고리즘 문제 풀이 전략"
categories: dev
tags: books
---

###### 조중필, 한현상, 이주호 저

<br>

#### 실력 향상을 고민하는 모든 프로그래머에게

- 많은 IT 기업에서 소프트웨어 개발자를 채용할 때 반드시 짚고 넘어가야 하는 관문으로 소프트웨어 시험 혹은 알고리즘 시험을 채택하고 있다.
- 제한된 시간과 환경에서 주어진 문제와 상황을 이해하고 그 문제를 해결하는 데 가장 최적화된 코딩을 할 수 있는 사람들을 선별해서 채용하길 원하기 때문이다.

<br>

#### 제대론 된 프로그래머가 되는 지름길

- 실력을 제대로 발휘하려면 현재 자신이 속한 상황을 이해하는 시간이 필요하고, 또 현실 상황과 자신의 실력을 비교하는 시간이 필요하다.

<br>

## PART 01 꼭 알아야 하는 필수 알고리즘

<br>

### CHAPTER 01 알고리즘의 역할

- 프로그래밍 언어 입문 과정을 배웠다는 것은 본격적으로 프로그래머의 길을 걸어가기 위한 준비의 한 과정이라고 받아들이면 된다.
- 주어진 조건이 있을 때 어떤 절차와 방법으로 문제를 풀 수 있는가?

<br>

#### section 01 알고리즘의 정의

- 문법만 확실히 익혔다고 해서 어떤 문제든 해결할 수 있는 것은 아니다.
- 알고리즘의 사전적 의미
  - `어떤 문제를 해결하기 위한 절차나 방법`
- 프로그래밍에서 의미하는 알고리즘
  - `어떤 문제를 컴퓨터를 사용해서 해결하기 위한 절차나 방법`

<br>

##### 알고리즘의 조건

- 알고리즘은 "문제를 해결하는 방법"을 의미한다.
- 주어진 문제를 해결하는 방법이나 절차가 맞는다면 알고리즘이라고 말할 수 있다.
- 알고리즘의 조건
  - `입력`: 알고리즘은 0 또는 그 이상의 외부에서 제공된 자료가 존재한다.
  - `출력`: 알고리즘은 최소 1개 이상의 결과가 있어야 한다.
  - `명확성`: 알고리즘의 각 단계는 애매함 없는 명확한 과정으로 구성되어야 한다.
  - `유한성`: 알고리즘은 유한한 수의 단계를 수행한 후 문제가 해결되고 종료되어야 한다.
  - `효율성`: 알고리즘의 모든 연산은 명백하게 실행할 수 있음을 검증할 수 있어야 한다.
- 일반적인 Hello World 프로그램
  - "Hello World라는 문자를 출력한다"는 명확한 목적이 있고, 문자를 출력한 다음에 해당 프로그램은 종료된다.
  - 또한 명백하게 실행할 수 있다는 점도 검증할 수 있다.
  - 즉, 아래 프로그램은 알고리즘의 조건을 만족한다고 볼 수 있다.

```c
# inlcude <stdio.h>

int main(int argc, char *argv[]) {
   printf("Hello, World!\n");
   
   return 0;
}
```

<br>

#### section 02 알고리즘을 왜 평가해야 하는가?

- 어떤 조건(Condition)이 중요하냐에 따라 효율적으로 문제를 해결하는 방법은 달라지기 마련이다.
- 알고리즘의 효율성을 평가하려면 다음을 기억해야 한다.
  - `컴퓨터를 사용해 주어진 조건에 맞게 효율적으로 문제를 해결하는 절차와 방법을 우선한다.`
- 보편적으로 알고리즘을 구현한다고 고민하는 일은 앞의 예처럼 알고리즘을 평가한 후 주어진 조건에 맞게 효율적으로 문제를 해결할 수 있는 알고리즘이 무엇인지 확인하는 일이다. 그리고 확인이 끝났다면 자신이 만드는 프로그램에 따라서 더 효율적이라고 생각하는 알고리즘을 적용해야 한다.

<br>

##### 알고리즘 평가의 세 가지 요소

###### 1) 시간의 효율성

- 시간의 효율성은 모든 알고리즘에서 가장 중요하게 생각하는 요소이다.
- 컴퓨터에서 실행되는 프로그램이라면 주어진 조건에 맞춰 문제를 해결하는 데 무한대의 시간을 사용할 수 는 없다.
- 되도록 빠른 시간 안에 가장 효율적인 해결책을 찾는 것이 좋은 알고리즘이다.

<br>

###### 2) 공간의 효율성

- 공간의 효율성은 컴퓨터에서 사용하는 메모리와 관계가 있다.
- 초보 프로그래머들이 흔히 저지르는 실수 중 하나는 프로그램에서 사용하는 모든 변수를 전역 변수로 선언해 사용한다는 점이다.
- 전역 변수는 지역 변수와 달리 프로그램의 실행 시점부터 종료 시점까지 메모리 공간을 계속 유지하므로 상당히 비효율적이다.
- 부득이한 경우에는 전역 변수를 사용해야 하겠지만 되도록 전역 변수의 사용을 줄여야 한다.

<br>

###### 3) 코드의 효율성

- 코드의 효율성은 프로그래머 입장에서 보는 코드의 효율성과 컴퓨터의 입장에서 보는 코드의 효율성이 있다.
- 프로그래머 입장에서 보는 코드의 효율성은 가독성(Readability)이 좋은 코드를 의미한다.
- 프로그램의 소스 코드는 되도록 다른 사람들이 보고 이해하기 쉽도록 작성해야 한다.
- 컴퓨터 입장에서 보는 효율성은 컴파일러와 하드웨어에 좀 더 최적화된 코드를 의미한다.
- 프로그래머 입장에서 재귀 호출을 사용하면 코드의 길이도 짧아지고 코드를 이해하는 데도 명쾌하다고 생각하기 쉽다. 하지만 실제 컴퓨터 입장에서 보면 재귀 호출을 위한 여러 가지 부가 작업이 필요할 수 있는데, 이것 역시 오버헤드(Overhead)를 일으킬 수 있다.

<br>

#### section 03 수학적 배경

<br>

##### 알고리즘의 수학적 표기 방법

- 빅오(O) 표기법(Big-O Notation)은 알고리즘의 성능 평가 방법 중 가장 많이 사용하는 방법이며, 최고의 성능과 최악의 성능 중 최악의 성능을 측정하는 방법이다.
- 최악의 성능을 측정해 평가하는 이유는 적어도 이 정도 성능 이상은 보장한다는 의미이다.
- 오메가(Ω) 표기법(Omega Notation)은 알고리즘의 성능이 최고인 경우를 측정하는 표기법이다. 그다지 자주 사용하지는 않는다.
- 세타(θ) 표기법(Theta Notation)은 정확한 알고리즘 성능을 측정하는 방법이다.
- 알고리즘을 분석하기 전에 필요한 몇 가지 가정
  - 헤더 파일은 알고리즘 성능에 영향을 주지 않는다.
  - 함수 진입과 함수 반환은 알고리즘 성능에 영향을 주지 않는다.
  - 프로그램은 첫 번째 행부터 마지막 행까지 차례로 실행된다.
- 빅오 표기법은 처리해야 할 데이터 양에 대한 실행 시간을 수학적으로 계산해 알고리즘의 성능을 평가한다.

<br>

##### 빅오 표기법의 종류

###### O(1)

- 처리해야 할 데이터 양과 상관없이 항상 일정한 실행 시간을 갖는 알고리즘을 의미한다.

<br>

###### O(logN)

- 처리해야 할 데이터 양이 증가할수록 실행 시간도 약간씩 증가하는 알고리즘을 의미한다.
- 단, 실행 시간의 증가 폭이 logN 그래프를 갖기 때문에 급격하게 증가하지는 않는다.
- 일반적으로 효율이 높은 검색 알고리즘의 성능이 이에 해당한다.

<br>

###### O(N)

- 처리해야 할 데이터 양과 비례해 실행 시간도 증가하는 경우이다.

<br>

###### O(NlonN)

- 처리해야 할 데이터 양보다 실행 시간이 좀 더 빠르게 증가한다.
- 일반적으로 효율이 높은 정렬 알고리즘의 성능이 이에 해당한다.

<br>

###### O(N^2)

- 보통 반복문이 2번 중첩된 경우의 알고리즘이다.

<br>

###### O(N^3)

- 반복문이 3번 중첩된 경우의 알고리즘이다.

<br>

###### O(2^N)

- 데이터 양의 증가에 따라 2^N만큼 실행 시간이 증가하는 알고리즘이다.

<br>

#### section 04 분석의 대상

<br>

##### 무엇을 분석할 것인가

- 알고리즘의 성능을 정확하게 평가한다는 것을 실제로 거의 불가능한 일이다.
- 알고리즘 성능 평가는 시간의 효율성, 공간의 효율성, 코드의 효율성으로 평가되어야 한다. 그러나 현실적으로 모두 평가 요소로 활용하기는 어렵다.
- 코드의 효율성은 프로그래밍 언어에 따라서 달라질 수 있으므로 객관적인(혹은 수학적인) 기준으로 평가하기가 어렵다.
- 공간의 효율성 역시 프로그램을 실행해서 실제 저장 공간의 사용량을 측정해보기 전에는 알고리즘이 얼마나 많은 메모리 혹은 기타 저장 공간을 사용하게 하는지 정확히 알기 어렵다.
- 결국 알고리즘의 성능을 평가하는 가장 현실적인 항목은 `시간의 효율성` 부분이다.
- 실제 구현한 알고리즘이 어느 정도의 시간을 소비하는지를 빅오 표기법으로 나타내보면 프로그램을 실행해보기 전이라도 객관적이고 수학적인 알고리즘의 성능 평가가 가능하게 된다.
- 대입 연산이나 연산자를 이용한 단순 연산 등은 알고리즘의 성능에 그다지 영향을 미치지 못한다.
- **알고리즘의 성능을 좌우하는 요소는 주로 반복문이다.**
- 어떤 알고리즘의 성능이 좋은지를 판단하려면, 알고리즘 안에 있는 반복문의 구성과 개수 등을 세밀하게 살펴볼 필요가 있다.

<br>

##### 반복문은 최대 반복 횟수로 계산한다

- 1부터 100까지의 수를 더하는 반복문
- 반복문이 하나 있는 경우의 최대 반복 횟수를 빅오 표기법으로 표시하면 O(100)이다. 그런데 빅오 표기법에서는 아무리 큰 수라도 상수인 경우는 무조건 1로 표시하므로 결국 이 반복문은 O(1)이 된다.

```javascript
for (i = 1; i <= 100; i++)
   sum += i;
```

<br>

##### 중첩된 반복문은 중첩문 각각의 최대 반복 횟수를 곱해서 계산한다

- 2개의 for문이 중첩된 경우에는 반복문 각각의 최대 반복 횟수를 곱해서 빅오 표기법을 계산한다.
- 첫 번째 반복문의 최대 반복 횟수는 N이며, 두 번째 반복문의 최대 반복 횟수도 N이 된다.
- 빅오 표기법으로 나타내면 O(N * N) = O(N^2)이 된다.

```javascript
for (i = 0; i < N; i++) {
   for (j = 0; j < N; j++) {
      k++;
   }
}
```

<br>

##### 반복문이 떨어져서 2개 이상 있는 경우는 그 중 가장 큰 값으로 계산한다

- 서로 떨어져 있는 2개의 반복문
- 첫 번째 for문과 두 번째 중첩 for문은 별개의 for문이다.
- 첫 번째 for문은 O(N)이 되며, 두 번째 for문은 O(N^2)이 된다.

```javascript
for (i = 0; i < N; i++) {
   sum = sum + i;
}

for (i = 0; i < N; i++) {
   for (j = 0; j < N; j++) {
      k++;
   }
}
```

<br>

##### if-else문은 알고리즘 성능에 영향을 미치지 않는다

<br>

##### 재귀 호출은 풀어서 계산한다

- 재귀 호출을 사용해 팩토리얼(factorial) 연산

```c
int Fact(int N)
{
   if(N <= 1)
      return 1;
   
   else
      return N * Fact(N - 1);
}
```

<br>

- 위 재귀 호출은 다음처럼 표현할 수 있다.

```c
N * (N - 1) * Fact(N - 2) = N * (N - 1) * (N - 2) * Fact(N - 3) = N * (N - 1) * (N - 2) * ... * 2 * 1
```

<br>

- 주의할 점이 있다. 위 재귀 호출 역시 반복 횟수는 N번이라는 것이다. 즉, 팩토리얼 연산과 같은 곱셈 연산도 덧셈 연산과 반복 횟수는 차이가 없다. 따라서 빅오 표기법으로 나타내면 위 팩토리얼 함수는 O(N)이다.

<br>

#### section 05 알고리즘의 분석과 최적화

<br>

##### 프로그램의 수학적 분석 예

- 알고리즘 성능에 제일 중요한 요소는 시간이다.
- 같은 기능을 실행하는 데 실행 시간을 얼마나 줄일 수 있느냐라는 것이 해당 알고리즘이 뛰어난 알고리즘인지 아니면 쓸모없는 알고리즘인지를 판단하는 기준이 된다.
- 실행 시간을 고려하지 않고 무작정 실시간으로 실행 시간을 확인한다는 것은 바보 같은 짓이다.
- 알고리즘의 성능이 뛰어나다는 것을 증명하는 가장 빠르고 정확한 방법이 바로 수학적 분석이다. 그리고 이 수학적 분석에서 가장 많이 이용하는 것이 빅오 표기법 기반의 분석이다.

<br>

##### 프로그램의 최적화 예

- 프로그램을 최적화한다는 말은 결국 해당 프로그램에서 사용하는 알고리즘을 최적화한다는 의미이다.
- 알고리즘을 최적화한다는 의미는 수학적인 접근 방법을 기반으로 프로그램을 살펴보고 필요하다면 고치는 것이다.
- 알고리즘의 성능을 좀 더 끌어올리는 최적화는, 이론적으로는 최악의 성능을 더 좋아지게 수정해 결국 전체적인 성능을 향상시키는 것이다.
- O(N^3)의 경우라면 O(N^2)로 만드는 것이 최적화에 해당하며, O(N^2)의 경우라면 O(NlogN)이나 더 나아가서 O(N)이 되도록 하는 것이 최적화에 해당할 것이다.
- 알고리즘을 최적화하려면 알고리즘의 전체 성능에 관한 빅오 표기법을 먼저 파악하고 해당 빅오 표기법의 성능을 높이는 방법으로 코드를 수정하는 것이 가장 좋은 방법이다.

<br>

#### section 06 정리

- 알고리즘의 기본 개념을 이해하고 성능을 평가할 방법을 아는 것이 중요하다.
- 시그마 연산을 계산해 반복문의 빅오 표기법이 무엇인지 확인하는 내용을 확실하게 이해했다면 앞으로 접하게 될 알고리즘을 살펴볼 때도 객관적이고 냉철한 시각을 갖게 될 것이다.

<br>

### CHAPTER 02 알고리즘을 배우기 전에 알아야 할 다섯 가지

<br>

#### section 01 메모리와 주소의 관계

- 메모리는 0과 1이 저장되는 2진수 기반 메모리 블록인 비트로 구성되어 있으며, 8개의 비트가 모인 1바이트 단위로 데이터(값)가 저장된다. 즉, 메모리에 어떤 데이터가 저장될 때는 1바이트의 메모리 블록 기준으로 저장된다는 의미이다.
- 데이터를 저장하거나 저장된 데이터를 불러올 때는 메모리의 위치 정보가 있는 메모리 주소(Address)를 사용해 접근한다.
- 메모리 주소는 데이터가 메모리에 저장될 때 함께 만들어진다.

<br>

#### section 02 자료형과 배열

<br>

##### 메모리와 자료형

- 프로그래머라면 실제 프로그래밍할 때 사용되는 논리적인 개념으로 메모리를 사용한다는 것을 이해해야 한다.
- 1바이트는 8비트이므로 2^8 = 256이라는 수를 표현할 수 있다.
- 우리가 다루는 논리적인 개념에서는 결국 10진수인 0~255를 다룬다.
- 프로그램 내부에서는 필요한 메모리의 단위를 바이트가 아닌 논리적인 개념 단위로 제공한다.
- 자료형은 프로그래밍 언어에 따라서 약간씩 다르지만, 자료형과 메모리의 관계에 대한 개념은 모든 프로그래밍 언어가 같다.
- 프로그래밍 언어에서 별도의 자료형을 제공하는 이유
  - 메모리 공간의 효율적 이용
  - 메모리를 효율적으로 저장하고 읽을 수 있게 하려고 자료형을 제공
- 모든 경우에 그렇다고 말할 수는 없지만, 보통 데이터를 연속적으로 읽고 쓸 때 각각의 변수를 만드는 것보다 메모리에 순차적으로 데이터를 저장해두고 사용하는 배열을 만드는 것이 훨씬 효율적이다.
- 자료구조를 만드는 데 기본이 되는 것이 자료형이다.
- 능숙한 프로그래머라면 자료구조에 따라 메모리를 효율적으로 관리할 수 있어야 한다.

<br>

##### 메모리와 배열

- 대부분의 프로그래밍 언어에서 메모리를 쉽게 사용하는 방법은 배열이다.
- 배열은 기본적으로 메모리에 연속적인 데이터를 저장할 수 있다.
- 배열을 사용해서 얻을 수 있는 장점은 하나의 배열 이름만으로 원하는 데이터를 저장하거나 가져올 수 있다는 점이다.
- 반면에 배열이 선언되는 순간 메모리를 확보한 상태가 되어 사용 영역이 고정되므로 프로그램 실행 중에 배열의 사용 영역을 변경할 수 없고, 프로그램을 종료하기 전까지는 해당 메모리 영역을 사용할 수 없다는 단점이 있다. 이러한 단점은 C 프로그램에서 배열 대신 포인터를 사용하게 된 원인이기도 하다.

<br>

#### section 03 배열의 응용

<br>

##### 함수와 일차원 배열의 사용

- 프로그래밍하다 보면 함수의 매개변수로 배열을 사용하는 경우가 종종 있다. 이런 경우 어떤 프로그래머는 아예 배열을 함수의 매개변수로 사용하지 않으려고 배열 자체를 전역 변수로 선언해서 사용하기도 한다. 그러나 이는 불필요하게 메모리를 많이 사용하게 되므로 피하는 것이 좋다.
- 함수의 매개변수로 배열을 사용하는 방법만 정확하게 알고 있다면 여러모로 유용하다.

<br>

##### 다차원 배열

- 실제 알고리즘을 개발하다 보면 1차원뿐만 아니라 2차원, 3차원 등 여러 가지 차원을 갖는 배열이 필요하다.

<br>

#### section 04 포인터

- 포인터는 C나 C++로 알고리즘을 개발할 때의 핵심 중 핵심이다. 가장 강력한 기능이면서도 가장 이해하기 어려운 기능이기도 하다. 반드시 넘어야 할 산이다.

<br>

##### 포인터는 왜 사용할까?

- C에서 메모리를 설명하면서 포인터(pointer)를 빠뜨릴 수 없다.
- 포인터는 사실 C 프로그램을 좀 더 쉽게 작성할 수 있도록 해주는 개념이다.
- 포인터는 메모리의 주소를 의미하는 2501호라는 값을 저장하는 변수를 말한다. 즉, 포인터는 메모리 주소를 저장하는 공간이므로 실제 메모리 안의 값이 아닌 메모리 주소가 저장된다.

<br>

### CHAPTER 03 기본적인 자료구조

<br>

#### section 01 링크드 리스트란?

- 