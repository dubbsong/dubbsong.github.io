---
layout: post
title: "알고리즘 문제 풀이 전략"
categories: dev
tags: books
---

###### 조중필, 한현상, 이주호 저

<br>

#### 실력 향상을 고민하는 모든 프로그래머에게

- 많은 IT 기업에서 소프트웨어 개발자를 채용할 때 반드시 짚고 넘어가야 하는 관문으로 소프트웨어 시험 혹은 알고리즘 시험을 채택하고 있다.
- 제한된 시간과 환경에서 주어진 문제와 상황을 이해하고 그 문제를 해결하는 데 가장 최적화된 코딩을 할 수 있는 사람들을 선별해서 채용하길 원하기 때문이다.

<br>

#### 제대론 된 프로그래머가 되는 지름길

- 실력을 제대로 발휘하려면 현재 자신이 속한 상황을 이해하는 시간이 필요하고, 또 현실 상황과 자신의 실력을 비교하는 시간이 필요하다.

<br>

## PART 01 꼭 알아야 하는 필수 알고리즘

<br>

### CHAPTER 01 알고리즘의 역할

- 프로그래밍 언어 입문 과정을 배웠다는 것은 본격적으로 프로그래머의 길을 걸어가기 위한 준비의 한 과정이라고 받아들이면 된다.
- 주어진 조건이 있을 때 어떤 절차와 방법으로 문제를 풀 수 있는가?

<br>

#### section 01 알고리즘의 정의

- 문법만 확실히 익혔다고 해서 어떤 문제든 해결할 수 있는 것은 아니다.
- 알고리즘의 사전적 의미
  - `어떤 문제를 해결하기 위한 절차나 방법`
- 프로그래밍에서 의미하는 알고리즘
  - `어떤 문제를 컴퓨터를 사용해서 해결하기 위한 절차나 방법`

<br>

##### 알고리즘의 조건

- 알고리즘은 "문제를 해결하는 방법"을 의미한다.
- 주어진 문제를 해결하는 방법이나 절차가 맞는다면 알고리즘이라고 말할 수 있다.
- 알고리즘의 조건
  - `입력`: 알고리즘은 0 또는 그 이상의 외부에서 제공된 자료가 존재한다.
  - `출력`: 알고리즘은 최소 1개 이상의 결과가 있어야 한다.
  - `명확성`: 알고리즘의 각 단계는 애매함 없는 명확한 과정으로 구성되어야 한다.
  - `유한성`: 알고리즘은 유한한 수의 단계를 수행한 후 문제가 해결되고 종료되어야 한다.
  - `효율성`: 알고리즘의 모든 연산은 명백하게 실행할 수 있음을 검증할 수 있어야 한다.
- 일반적인 Hello World 프로그램
  - "Hello World라는 문자를 출력한다"는 명확한 목적이 있고, 문자를 출력한 다음에 해당 프로그램은 종료된다.
  - 또한 명백하게 실행할 수 있다는 점도 검증할 수 있다.
  - 즉, 아래 프로그램은 알고리즘의 조건을 만족한다고 볼 수 있다.

```c
# inlcude <stdio.h>

int main(int argc, char *argv[]) {
   printf("Hello, World!\n");
   
   return 0;
}
```

<br>

#### section 02 알고리즘을 왜 평가해야 하는가?

- 어떤 조건(Condition)이 중요하냐에 따라 효율적으로 문제를 해결하는 방법은 달라지기 마련이다.
- 알고리즘의 효율성을 평가하려면 다음을 기억해야 한다.
  - `컴퓨터를 사용해 주어진 조건에 맞게 효율적으로 문제를 해결하는 절차와 방법을 우선한다.`
- 보편적으로 알고리즘을 구현한다고 고민하는 일은 앞의 예처럼 알고리즘을 평가한 후 주어진 조건에 맞게 효율적으로 문제를 해결할 수 있는 알고리즘이 무엇인지 확인하는 일이다. 그리고 확인이 끝났다면 자신이 만드는 프로그램에 따라서 더 효율적이라고 생각하는 알고리즘을 적용해야 한다.

<br>

##### 알고리즘 평가의 세 가지 요소

###### 1) 시간의 효율성

- 시간의 효율성은 모든 알고리즘에서 가장 중요하게 생각하는 요소이다.
- 컴퓨터에서 실행되는 프로그램이라면 주어진 조건에 맞춰 문제를 해결하는 데 무한대의 시간을 사용할 수 는 없다.
- 되도록 빠른 시간 안에 가장 효율적인 해결책을 찾는 것이 좋은 알고리즘이다.

<br>

###### 2) 공간의 효율성

- 공간의 효율성은 컴퓨터에서 사용하는 메모리와 관계가 있다.
- 초보 프로그래머들이 흔히 저지르는 실수 중 하나는 프로그램에서 사용하는 모든 변수를 전역 변수로 선언해 사용한다는 점이다.
- 전역 변수는 지역 변수와 달리 프로그램의 실행 시점부터 종료 시점까지 메모리 공간을 계속 유지하므로 상당히 비효율적이다.
- 부득이한 경우에는 전역 변수를 사용해야 하겠지만 되도록 전역 변수의 사용을 줄여야 한다.

<br>

###### 3) 코드의 효율성

- 코드의 효율성은 프로그래머 입장에서 보는 코드의 효율성과 컴퓨터의 입장에서 보는 코드의 효율성이 있다.
- 프로그래머 입장에서 보는 코드의 효율성은 가독성(Readability)이 좋은 코드를 의미한다.
- 프로그램의 소스 코드는 되도록 다른 사람들이 보고 이해하기 쉽도록 작성해야 한다.
- 컴퓨터 입장에서 보는 효율성은 컴파일러와 하드웨어에 좀 더 최적화된 코드를 의미한다.
- 프로그래머 입장에서 재귀 호출을 사용하면 코드의 길이도 짧아지고 코드를 이해하는 데도 명쾌하다고 생각하기 쉽다. 하지만 실제 컴퓨터 입장에서 보면 재귀 호출을 위한 여러 가지 부가 작업이 필요할 수 있는데, 이것 역시 오버헤드(Overhead)를 일으킬 수 있다.

<br>

#### section 03 수학적 배경

<br>

##### 알고리즘의 수학적 표기 방법

- 빅오(O) 표기법(Big-O Notation)은 알고리즘의 성능 평가 방법 중 가장 많이 사용하는 방법이며, 최고의 성능과 최악의 성능 중 최악의 성능을 측정하는 방법이다.
- 최악의 성능을 측정해 평가하는 이유는 적어도 이 정도 성능 이상은 보장한다는 의미이다.
- 오메가(Ω) 표기법(Omega Notation)은 알고리즘의 성능이 최고인 경우를 측정하는 표기법이다. 그다지 자주 사용하지는 않는다.
- 세타(θ) 표기법(Theta Notation)은 정확한 알고리즘 성능을 측정하는 방법이다.
- 알고리즘을 분석하기 전에 필요한 몇 가지 가정
  - 헤더 파일은 알고리즘 성능에 영향을 주지 않는다.
  - 함수 진입과 함수 반환은 알고리즘 성능에 영향을 주지 않는다.
  - 프로그램은 첫 번째 행부터 마지막 행까지 차례로 실행된다.
- 빅오 표기법은 처리해야 할 데이터 양에 대한 실행 시간을 수학적으로 계산해 알고리즘의 성능을 평가한다.

<br>

##### 빅오 표기법의 종류

###### O(1)

- 처리해야 할 데이터 양과 상관없이 항상 일정한 실행 시간을 갖는 알고리즘을 의미한다.

<br>

###### O(logN)

- 처리해야 할 데이터 양이 증가할수록 실행 시간도 약간씩 증가하는 알고리즘을 의미한다.
- 단, 실행 시간의 증가 폭이 logN 그래프를 갖기 때문에 급격하게 증가하지는 않는다.
- 일반적으로 효율이 높은 검색 알고리즘의 성능이 이에 해당한다.

<br>

###### O(N)

- 처리해야 할 데이터 양과 비례해 실행 시간도 증가하는 경우이다.

<br>

###### O(NlonN)

- 처리해야 할 데이터 양보다 실행 시간이 좀 더 빠르게 증가한다.
- 일반적으로 효율이 높은 정렬 알고리즘의 성능이 이에 해당한다.

<br>

###### O(N^2)

- 보통 반복문이 2번 중첩된 경우의 알고리즘이다.

<br>

###### O(N^3)

- 반복문이 3번 중첩된 경우의 알고리즘이다.

<br>

###### O(2^N)

- 데이터 양의 증가에 따라 2^N만큼 실행 시간이 증가하는 알고리즘이다.

<br>

#### section 04 분석의 대상

<br>

##### 무엇을 분석할 것인가

- 알고리즘의 성능을 정확하게 평가한다는 것을 실제로 거의 불가능한 일이다.
- 알고리즘 성능 평가는 시간의 효율성, 공간의 효율성, 코드의 효율성으로 평가되어야 한다. 그러나 현실적으로 모두 평가 요소로 활용하기는 어렵다.
- 코드의 효율성은 프로그래밍 언어에 따라서 달라질 수 있으므로 객관적인(혹은 수학적인) 기준으로 평가하기가 어렵다.
- 공간의 효율성 역시 프로그램을 실행해서 실제 저장 공간의 사용량을 측정해보기 전에는 알고리즘이 얼마나 많은 메모리 혹은 기타 저장 공간을 사용하게 하는지 정확히 알기 어렵다.
- 결국 알고리즘의 성능을 평가하는 가장 현실적인 항목은 `시간의 효율성` 부분이다.
- 실제 구현한 알고리즘이 어느 정도의 시간을 소비하는지를 빅오 표기법으로 나타내보면 프로그램을 실행해보기 전이라도 객관적이고 수학적인 알고리즘의 성능 평가가 가능하게 된다.
- 대입 연산이나 연산자를 이용한 단순 연산 등은 알고리즘의 성능에 그다지 영향을 미치지 못한다.
- **알고리즘의 성능을 좌우하는 요소는 주로 반복문이다.**
- 어떤 알고리즘의 성능이 좋은지를 판단하려면, 알고리즘 안에 있는 반복문의 구성과 개수 등을 세밀하게 살펴볼 필요가 있다.

<br>

##### 반복문은 최대 반복 횟수로 계산한다

- 1부터 100까지의 수를 더하는 반복문
- 반복문이 하나 있는 경우의 최대 반복 횟수를 빅오 표기법으로 표시하면 O(100)이다. 그런데 빅오 표기법에서는 아무리 큰 수라도 상수인 경우는 무조건 1로 표시하므로 결국 이 반복문은 O(1)이 된다.

```javascript
for (i = 1; i <= 100; i++)
   sum += i;
```

<br>

##### 중첩된 반복문은 중첩문 각각의 최대 반복 횟수를 곱해서 계산한다

- 2개의 for문이 중첩된 경우에는 반복문 각각의 최대 반복 횟수를 곱해서 빅오 표기법을 계산한다.
- 첫 번째 반복문의 최대 반복 횟수는 N이며, 두 번째 반복문의 최대 반복 횟수도 N이 된다.
- 빅오 표기법으로 나타내면 O(N * N) = O(N^2)이 된다.

```javascript
for (i = 0; i < N; i++) {
   for (j = 0; j < N; j++) {
      k++;
   }
}
```

<br>

##### 반복문이 떨어져서 2개 이상 있는 경우는 그 중 가장 큰 값으로 계산한다

- 서로 떨어져 있는 2개의 반복문
- 첫 번째 for문과 두 번째 중첩 for문은 별개의 for문이다.
- 첫 번째 for문은 O(N)이 되며, 두 번째 for문은 O(N^2)이 된다.

```javascript
for (i = 0; i < N; i++) {
   sum = sum + i;
}

for (i = 0; i < N; i++) {
   for (j = 0; j < N; j++) {
      k++;
   }
}
```

<br>

##### if-else문은 알고리즘 성능에 영향을 미치지 않는다

<br>

##### 재귀 호출은 풀어서 계산한다

- 재귀 호출을 사용해 팩토리얼(factorial) 연산

```c
int Fact(int N)
{
   if(N <= 1)
      return 1;
   
   else
      return N * Fact(N - 1);
}
```

<br>

- 위 재귀 호출은 다음처럼 표현할 수 있다.

```c
N * (N - 1) * Fact(N - 2) = N * (N - 1) * (N - 2) * Fact(N - 3) = N * (N - 1) * (N - 2) * ... * 2 * 1
```

<br>

- 주의할 점이 있다. 위 재귀 호출 역시 반복 횟수는 N번이라는 것이다. 즉, 팩토리얼 연산과 같은 곱셈 연산도 덧셈 연산과 반복 횟수는 차이가 없다. 따라서 빅오 표기법으로 나타내면 위 팩토리얼 함수는 O(N)이다.

<br>

#### section 05 알고리즘의 분석과 최적화

<br>

##### 프로그램의 수학적 분석 예

- 알고리즘 성능에 제일 중요한 요소는 시간이다.
- 같은 기능을 실행하는 데 실행 시간을 얼마나 줄일 수 있느냐라는 것이 해당 알고리즘이 뛰어난 알고리즘인지 아니면 쓸모없는 알고리즘인지를 판단하는 기준이 된다.
- 실행 시간을 고려하지 않고 무작정 실시간으로 실행 시간을 확인한다는 것은 바보 같은 짓이다.
- 알고리즘의 성능이 뛰어나다는 것을 증명하는 가장 빠르고 정확한 방법이 바로 수학적 분석이다. 그리고 이 수학적 분석에서 가장 많이 이용하는 것이 빅오 표기법 기반의 분석이다.

<br>

##### 프로그램의 최적화 예

- 프로그램을 최적화한다는 말은 결국 해당 프로그램에서 사용하는 알고리즘을 최적화한다는 의미이다.
- 알고리즘을 최적화한다는 의미는 수학적인 접근 방법을 기반으로 프로그램을 살펴보고 필요하다면 고치는 것이다.
- 알고리즘의 성능을 좀 더 끌어올리는 최적화는, 이론적으로는 최악의 성능을 더 좋아지게 수정해 결국 전체적인 성능을 향상시키는 것이다.
- O(N^3)의 경우라면 O(N^2)로 만드는 것이 최적화에 해당하며, O(N^2)의 경우라면 O(NlogN)이나 더 나아가서 O(N)이 되도록 하는 것이 최적화에 해당할 것이다.
- 알고리즘을 최적화하려면 알고리즘의 전체 성능에 관한 빅오 표기법을 먼저 파악하고 해당 빅오 표기법의 성능을 높이는 방법으로 코드를 수정하는 것이 가장 좋은 방법이다.

<br>

#### section 06 정리

- 알고리즘의 기본 개념을 이해하고 성능을 평가할 방법을 아는 것이 중요하다.
- 시그마 연산을 계산해 반복문의 빅오 표기법이 무엇인지 확인하는 내용을 확실하게 이해했다면 앞으로 접하게 될 알고리즘을 살펴볼 때도 객관적이고 냉철한 시각을 갖게 될 것이다.

<br>

### CHAPTER 02 알고리즘을 배우기 전에 알아야 할 다섯 가지

<br>

#### section 01 메모리와 주소의 관계

- 메모리는 0과 1이 저장되는 2진수 기반 메모리 블록인 비트로 구성되어 있으며, 8개의 비트가 모인 1바이트 단위로 데이터(값)가 저장된다. 즉, 메모리에 어떤 데이터가 저장될 때는 1바이트의 메모리 블록 기준으로 저장된다는 의미이다.
- 데이터를 저장하거나 저장된 데이터를 불러올 때는 메모리의 위치 정보가 있는 메모리 주소(Address)를 사용해 접근한다.
- 메모리 주소는 데이터가 메모리에 저장될 때 함께 만들어진다.

<br>

#### section 02 자료형과 배열

<br>

##### 메모리와 자료형

- 프로그래머라면 실제 프로그래밍할 때 사용되는 논리적인 개념으로 메모리를 사용한다는 것을 이해해야 한다.
- 1바이트는 8비트이므로 2^8 = 256이라는 수를 표현할 수 있다.
- 우리가 다루는 논리적인 개념에서는 결국 10진수인 0~255를 다룬다.
- 프로그램 내부에서는 필요한 메모리의 단위를 바이트가 아닌 논리적인 개념 단위로 제공한다.
- 자료형은 프로그래밍 언어에 따라서 약간씩 다르지만, 자료형과 메모리의 관계에 대한 개념은 모든 프로그래밍 언어가 같다.
- 프로그래밍 언어에서 별도의 자료형을 제공하는 이유
  - 메모리 공간의 효율적 이용
  - 메모리를 효율적으로 저장하고 읽을 수 있게 하려고 자료형을 제공
- 모든 경우에 그렇다고 말할 수는 없지만, 보통 데이터를 연속적으로 읽고 쓸 때 각각의 변수를 만드는 것보다 메모리에 순차적으로 데이터를 저장해두고 사용하는 배열을 만드는 것이 훨씬 효율적이다.
- 자료구조를 만드는 데 기본이 되는 것이 자료형이다.
- 능숙한 프로그래머라면 자료구조에 따라 메모리를 효율적으로 관리할 수 있어야 한다.

<br>

##### 메모리와 배열

- 대부분의 프로그래밍 언어에서 메모리를 쉽게 사용하는 방법은 배열이다.
- 배열은 기본적으로 메모리에 연속적인 데이터를 저장할 수 있다.
- 배열을 사용해서 얻을 수 있는 장점은 하나의 배열 이름만으로 원하는 데이터를 저장하거나 가져올 수 있다는 점이다.
- 반면에 배열이 선언되는 순간 메모리를 확보한 상태가 되어 사용 영역이 고정되므로 프로그램 실행 중에 배열의 사용 영역을 변경할 수 없고, 프로그램을 종료하기 전까지는 해당 메모리 영역을 사용할 수 없다는 단점이 있다. 이러한 단점은 C 프로그램에서 배열 대신 포인터를 사용하게 된 원인이기도 하다.

<br>

#### section 03 배열의 응용

<br>

##### 함수와 일차원 배열의 사용

- 프로그래밍하다 보면 함수의 매개변수로 배열을 사용하는 경우가 종종 있다. 이런 경우 어떤 프로그래머는 아예 배열을 함수의 매개변수로 사용하지 않으려고 배열 자체를 전역 변수로 선언해서 사용하기도 한다. 그러나 이는 불필요하게 메모리를 많이 사용하게 되므로 피하는 것이 좋다.
- 함수의 매개변수로 배열을 사용하는 방법만 정확하게 알고 있다면 여러모로 유용하다.

<br>

##### 다차원 배열

- 실제 알고리즘을 개발하다 보면 1차원뿐만 아니라 2차원, 3차원 등 여러 가지 차원을 갖는 배열이 필요하다.

<br>

#### section 04 포인터

- 포인터는 C나 C++로 알고리즘을 개발할 때의 핵심 중 핵심이다. 가장 강력한 기능이면서도 가장 이해하기 어려운 기능이기도 하다. 반드시 넘어야 할 산이다.

<br>

##### 포인터는 왜 사용할까?

- C에서 메모리를 설명하면서 포인터(pointer)를 빠뜨릴 수 없다.
- 포인터는 사실 C 프로그램을 좀 더 쉽게 작성할 수 있도록 해주는 개념이다.
- 포인터는 메모리의 주소를 의미하는 2501호라는 값을 저장하는 변수를 말한다. 즉, 포인터는 메모리 주소를 저장하는 공간이므로 실제 메모리 안의 값이 아닌 메모리 주소가 저장된다.

<br>

### CHAPTER 03 기본적인 자료구조

<br>

#### section 01 링크드 리스트란?

- 링크드 리스트(Linked List)는 대부분의 알고리즘에서 사용하는 자료구조다.
- 프로그램 실행 중에도 동적으로 새로운 노드를 삽입하거나 삭제하기가 간편하며, 링크라는 개념을 통해 물리 메모리를 연속적으로 사용하지 않아도 되므로 관리하기가 쉽다.
- 링크드 리스트에는 기본적으로 노드(Node)와 링크(Link)라는 용어를 사용한다. 마치 열차와 같은 구조다. 열차의 객차처럼 생긴 사각형 각각이 하나의 노드고, 객차와 객차를 연결해주는 쇠사슬이 링크라고 생각하면, 링크드 리스트의 노드와 링크의 관계를 이해하기 쉽다.
- 객차가 서로 연결되어 있는 것만으로는 아직 어떤 의미가 있는 것은 아니다. 연결된 객차들에 의미를 부여해주어야 한다. 이 역할을 하려고 일반 노드의 맨 앞에는 헤드노드가 있다.
- 승객이 기관차에는 타지 않는 것처럼, 링크드 리스트의 헤드 노드에는 데이터를 저장하지 않는다. 단지 링크드 리스트의 시작 부분임을 나타낼 뿐이다.
- 링크드 리스트의 마지막 부분을 나타내는 노드도 있다. 엔드 노드(End Node) 또는 테일 노드(Tail Node)라고 부르는데, 이 역시 데이터를 저장하지 않는 노드이다.
- 좀 더 정확하게 얘기하면, 헤드 노드와 엔드 노드에는 데이터를 저장할 수 없는 것이 아니라, 묵시적으로 데이터를 저장하지 않는다는 표현이 더 맞다.
- 결국 실제 데이터가 저장되는 노드들은 링크드 리스트의 처음과 끝을 가리키는 노드 사이에 있게 된다.

<br>

#### section 02 단일 링크드 리스트의 삽입과 삭제

<br>

##### 단일 링크드 리스트의 특징

- 사실 링크드 리스트는 자료를 저장하는 자료구조의 하나에 불과하다.
- 하나 이상의 데이터를 저장한다는 면에서 기본 개념은 배열하고 거의 같다.
- 단일 링크드 리스트의 장점은 곧 배열의 단점이다.
- 배열은 같은 자료형을 갖는 데이터의 집합으로, 특성은 연속적인 데이터를 저장한다는 데 있다. 그런데 배열은 생성할 때 데이터를 저장하는 데 필요한 모든 메모리를 한 번에 확보해 사용할 수 있게 해주므로 프로그램이 실행되는 중간에 배열의 크기를 바꿀 수가 없다. 따라서 배열 안에 저장되어 있는 값들을 정렬할 때도 메모리에 저장되어 있는 각각의 값을 바꿔주어야 한다. 단일 링크드 리스트는 이와 같은 배열의 단점을 해결해준다.
- 배열은 연속된 메모리를 사용하지만 단일 링크드 리스트는 반드시 연속적이라고는 볼 수 없다. 오히려 연속적이지 않는 데이터들을 링크로 서로 연결하는 개념이라고 볼 수 있다.

<br>

##### 단일 링크드 리스트의 삽입 알고리즘

- 단일 링크드 리스트는 노드 각각이 링크를 통해 연결되어 있다. 따라서 단일 링크드 리스트의 중간에 새로운 노드를 만들어서 어떤 값을 연결시키는 것은 간단하다.
- 예를 들어 A, B, D, E 총 4개의 노드가 있다고 가정해보자. 노드 B와 노드 D 사이에 노드 C를 삽입하려면 새로 삽입되는 노드 C가 노드 D를 가리키도록 하고, 원래 노드 D를 가리키던 노드 B가 노드 C를 가리키도록 해야 한다. 이때 주의할 점은 링크의 순서를 바꾸면 절대 안 된다.
- 단일 링크드 리스트가 아니라 배열이라면, 데이터 사이에 데이터를 삽입하기 위해서는 데이터가 한 칸씩 뒤로 이동해야 한다.
- 배열의 데이터 삽입에서, 1,000개의 데이터가 있고 새로운 데이터가 두 번째 위치에 삽입된다고 하면 무려 999번의 데이터 이동이 필요하다.
- 단일 링크드 리스트 삽입 알고리즘의 핵심 코드는 노드를 삽입하는 `InsertNode()` 함수다.
- 배열의 경우는 노드의 수가 많으면 많을수록 이동하는 데이터도 증가되며, 따라서 for문의 반복 횟수도 계속 증가한다.
- 단일 링크드 리스트의 경우는 노드의 수와는 상관없이 언제나 두 행의 코드만이 실행된다.

<br>

##### 단일 링크드 리스트의 삭제 알고리즘

- 삭제 알고리즘은 삽입 알고리즘의 변형이다.
- 삭제 알고리즘도 삽입 알고리즘과 같이 크게 2개의 부분으로 나눌 수 있다. 삭제할 노드를 검색하는 부분과 노드를 실제로 삭제하는 부분이다.
- 삭제 알고리즘에서도 하나의 노드가 삭제되면 해당 노드가 차지하는 메모리 공간을 삭제해주어야 한다.

<br>

#### section 03 이중 링크드 리스트

- 링크드 리스트에는 2개의 링크를 갖는 이중 링크드 리스트와 링크드 리스트가 원형으로 구성된 원형 링크드 리스트가 있다.

<br>

##### 이중 링크드 리스트

- 단일 링크드 리스트는 무조건 한 방향으로만 링크를 따라 가야 하므로 다소 불편한 점이 있다. 이러한 문제를 해결하려는 개념이 바로 `이중/원형 링크드 리스트`다.
- 이중 링크드 리스트는 노드 각각이 양방향으로 연결되어 있고, 원형 링크드 리스트는 각 노드의 끝이 서로 연결된 형태로 되어 있다.

<br>

#### section 04 스택의 개념과 알고리즘

- 스택(Stack)과 큐(Queue)는 프로그래밍을 시작할 때부터 사용된 가장 고전적인 자료구조이며, 그중에서도 스택은 거의 모든 애플리케이션을 만들 때 사용되는 기본 자료구조다. 따라서 스택과 연관된 알고리즘을 제대로 이해하느냐 못하느냐에 따라서 기본 알고리즘을 설계할 수 있느냐 없느냐가 결정되기도 한다.

<br>

##### 스택의 개념

- 스택의 기본 개념을 프로그래밍 시각에서 설명하면 '`입력과 출력을 한 방향으로 제한한 자료구조`'라고 말할 수 있다.
- 배열과 링크드 리스트는 일단 데이터를 넣거나 빼는 작업 자체가 좀 복잡하다.
- 스택이란 바닥부터 데이터를 차곡차곡 쌓는다는 개념으로 이해하면 된다.
- 예를 들어 100개의 접시를 쌓는다고 가정하자. 첫 번째 접시를 닦아서 찬장에 놓아 두고 나면 두 번째 이후로 닦은 접시는 이전 접시 위에 올려놓을 것이다. 이러한 과정을 거쳐서 100번째로 닦은 접시가 가장 위에 올려질 것이다. 이와 같은 과정을 스택에서는 `푸시(Push)`라고 한다.
- 찬장에서 접시를 하나 빼서 사용할 때는 가장 위에 놓여 있는 접시부터 사용할 것이다. 이 과정을 스택에서는 팝(Pop)이라고 한다.
- 스택 알고리즘에서는 딱 두 가지만 기억해두자.
  1. `Push`: 접시를 닦아서 찬장에 쌓아놓는다. 즉, 데이터에 순서를 적용해 차례로 저장한다.
  2. `Pop`: 접시를 사용하려고 찬장에서 가장 위에 있는 접시를 갖고 온다. 즉, 가장 최신 데이터부터 차례로 가져온다. 이와 같은 방식을 `LIFO(Last In First Out)`라고 한다. 마지막으로 들어간 것이 제일 처음 나온다는 의미다.
- 스택과 관련된 알고리즘은 `설거지 알고리즘`이라고 기억해두자.

<br>

##### 스택의 구현

- 스택을 구현하려면 접시를 쌓아두는 찬장에 해당하는 메모리 공간과 그에 맞는 하위 자료구조를 정해야 한다.
- 하위 자료 구조는 배열이나 링크드 리스트 둘 중에 어느 것을 사용해도 사실 상관없다.

<br>

##### 푸시와 팝

- 스택에서 필요한 함수는 스택에 데이터를 넣는 `Push()` 함수와 스택에서 데이터를 가져오는 `Pop()` 함수다.

<br>

#### section 05 큐의 개념과 알고리즘

- 큐(Queue)를 사용하는 대표적인 소프트웨어는 윈도우나 리눅스 같은 운영체제다.

<br>

##### 큐의 개념

- 스택이 LIFO 방식이라면, 큐는 `FIFO(First In First Out)` 방식을 사용한다.
- 큐의 개념은 극장 매표소 앞에서 줄을 서는 것과 비슷하다. 극장 매표소 앞에 줄을 선다는 것은 앞 사람이 나보다 먼저 극장에 도착했다는 의미가 된다. 나보다 늦게 도착한 사람은 내 뒤에 서야 한다.
- 큐 알고리즘에서 기억할 두 가지
  1. `Put`: 매표소 앞에서 줄을 선다. 즉, 도착하는 차례대로 데이터를 저장한다.
  2. `Get`: 줄을 선 순서대로 앞에서부터 표를 산다. 즉, 처음 저장된 데이터부터 차례로 사용한다.
- 큐 알고리즘도 스택 알고리즘과 마찬가지로 3개의 함수가 필요하다. 큐를 초기화하는 `InitializeQueue()` 함수, 큐에서 데이터를 저장하는 `Put()` 함수, 큐에서 데이터를 가져오는 `Get()` 함수다.
- 큐의 입구를 나타내는 변수인 `Rear` 변수와, 큐의 출구를 나타내는 변수인 `Front`를 선언할 필요가 있다.

<br>

##### 배열을 사용한 큐의 구현

- 스택과는 달리 큐는 배열을 사용하는 것이 좀 더 편리하다.

<br>

### CHAPTER 04 트리

<br>

#### section 01 트리의 개념과 주요 용어

<br>

##### 트리 관련 주요 용어

- root node
  - 연결된 노드가 한 군데로 모이는 상위에 위치하는 노드를 루트 노드라고 한다.
- 차수 (degree)
  - 한 노드에 연결된 서버 트리의 개수를 차수라고 한다.
  - 차수가 2개 이하인 트리 구조를 특별히 이진 트리(Binary Tree)라고 한다.
- 부모 노드 (parent node)
  - 현재의 노드에 연결되어 있는 바로 상위 노드를 부모 노드라고 한다.
  - 트리 구조에서는 루트 노드를 제외하고는 모든 노드가 하나의 부모 노드를 가져와야 한다.
  - 부모 노드가 2개 이상 존재하면 그 구조는 트리 구조가 될 수 없다.
- 자식 노드 (child node)
  - 부모 노드의 반대 개념. 즉 자신보다 아래에 있는 노드를 자식 노드라고 한다. 트리 구조에 자식 노드는 몇 개라도 상관없지만, 이진 트리의 경우는 반드시 자식 노드의 수가 2개 이하가 되어야 한다.
- 형제 노드 (sibling node)
  - 같은 부모 노드를 갖는 노드 사이를 형제 노드라고 한다.
- 리프 노드 (leaf node)
  - 트리 구조에서 최상위 노드를 루트 노드라고 하듯이, 가장 끝에 있는 최하위 노드를 리프 노드라고 한다.
  - 단말 혹은 터미널 노드(terminal node)라고도 한다.
- 레벨 (level)
  - 레벨은 루트 노드부터 해당 노드까지 경로를 찾는데 방문한 총 노드의 수가 된다.
- 높이 혹은 깊이 (height or depth)
  - 트리의 최대 레벨 수를 트리의 높이 혹은 트리의 깊이라고 한다.

<br>

##### 이진 트리

- 트리의 차수(degree)가 2 이하인 트리를 의미한다.
- 자식 노드가 2개만 존재하므로 구현이 쉽다는 장점이 있다.

<br>

##### 완전 이진 트리 (Complete Binary Tree)

- 모든 노드에 자식 노드가 하나도 없거나, 아니면 2개의 자식 노드를 갖는 이진 트리를 말한다.

<br>

##### 정 이진 트리 (Full Binary Tree)

- 리프 노드들의 레벨이 같아야 하는 트리를 의미한다.

<br>

##### 트리의 순회 알고리즘

- 트리는 기본적으로 순회 알고리즘이라는 것을 구현해서 사용하게 된다.
- 순회(Traverse)는 트리 구조에서 각각의 노드를 방문하는 것으로, 크게 네 가지 방법이 있다.
  1. 전위 순회 (Pre-Order Traverse)
  2. 중위 순회 (In-Order Traverse)
  3. 후위 순회 (Post-Order Traverse)
  4. 단계 순회 (Level-Order Traverse)

<br>

### section 02 전위 순회 알고리즘

```js
     A
  B    C
D  E  F  G
```

<br>

- 트리 구조를 순회하는 데 반드시 지켜야 할 기본 규칙은 '`노드는 오직 한 번만 방문한다`'는 것이다.
- 전위 순회의 규칙
  1. 루트 ㄴ노드에서 계속 왼쪽으로 이동하면서 하나의 리프 노드가 나올 때까지 순서대로 방문한다.
  2. 1번 리프 노드의 부모 노드 아래에 있는 오른쪽 리프 노드를 방문한다. 예를 들어 부모 노드인 A의 오른쪽 리프 노드인 C를 방문하게 된다.
  3. 왼쪽 방향을 기준으로 다음에 위치한 2번 과정과 같은 레벨의 부모 노드를 방문한다.
  4. 왼쪽에 있는 리프 노드를 방문한다.
  5. 바로 전 부모 노드 아래에 있는 오른쪽 리프 노드를 방문한다.
- 방문 결과는 `A-B-D-E-C-F-G`가 된다.

<br>

### section 03 중위 순회 알고리즘

```js
     A
  B    C
D  E  F  G
```

<br>

- 중위 순회 알고리즘을 한 문장으로 표현하면 '`왼쪽 자식 노드를 방문하고, 그 다음 부모 노드를 방문한 후, 다시 오른쪽 자식 노드를 방문`'하는 알고리즘이다.
- 중위 순회의 규칙
  1. 맨 왼쪽에 있는 리프 노드로 이동해서 방문한다.
  2. 바로 전 부모 노드로 이동한다.
  3. 해당 부모 노드의 오른쪽 리프 노드로 이동해 방문한다.
  4. 다시 2번 과정 노드의 부모 노드로 이동한다.
  5. 4번 노드의 오른쪽 자식 노드 중 가장 왼쪽에 있는 리프 노드로 이동해 방문한다.
  6. 전체 트리의 맨 오른쪽 리프 노드에 도착할 때까지 2번 ~ 5번 과정을 반복한다.
- 방문 결과는 `D-B-E-A-F-C-G`가 된다.

<br>

### section 04 후위 순회 알고리즘

```js
     A
  B    C
D  E  F  G
```

<br>

- 후위 순회의 규칙
  1. 맨 왼쪽에 있는 리프 노드로 이동해 방문한다.
  2. 해당 부모 노드의 오른쪽 리프 노드로 이동해 방문한다.
  3. 2번 과정의 부모 노드로 다시 이동해 방문한다.
  4. 2번 과정 부모 노드와 레벨이 같은 오른쪽 노드로 이동한 후, 자식 노드 중 가장 왼쪽에 있는 리프 노드로 이동해 방문한다.
  5. 4번 과정의 오른쪽 리프 노드로 이동해 방문한다.
  6. 2번 ~ 5번 과정을 루트 노드에 도달할 때까지 반복한다.
- 방문 결과는 `D-E-B-F-G-C-A`가 된다.

<br>

### section 05 단계 순회 알고리즘

- 단계 순회 알고리즘은 루트 노드부터 레벨 순서대로 왼쪽 노드와 오른쪽 노드를 차례로 방문하는 순회 알고리즘이다.
- 알파벳 순서 그대로인 `A-B-C-D-E-F-G`의 순서로 방문한다.

<br>

### section 06 정리

- 트리 구조에서 자식 노드가 2개 이하인 노드를 이진 트리(Binary Tree)라고 하며, 이는 알고리즘에서 가장 많이 사용되고 있는 개념이다.
- 이진 트리를 순회하는 알고리즘은 전위, 중위, 후위, 단계 순회 알고리즘의 네 가지가 있으며, 각각의 알고리즘은 재귀 호출, 스택이나 큐를 사용해 구현할 수 있다.
- 재귀 호출을 사용하는 전위, 중위, 후위 순회 알고리즘은 몇 줄의 코드만으로 구현할 수 있지만, 스택을 사용하는 경우는 이진 트리의 구성에 따라 고려해야 할 부분들이 꽤 있다.
- 구현해야 할 알고리즘의 특징에 맞춰 재귀 호출, 스택, 큐 중에서 더 잘 맞는 구현 방식을 선택하기 바란다.

<br>