---
layout: post
title: "알고리즘 시간복잡도 Big-O"
categories: dev
tags: etc
---

## 시간복잡도

- 알고리즘이 수행되는 시간이 시간복잡도.

- 주로 Big-O 표기법을 사용.

  알고리즘이 최악일 때 어떤 성능을 지녔는지 판단해야 평균과 가까운 성능을 예측할 수 있기 때문.

- 시간복잡도를 분석하는 것은 input n에 대하여 알고리즘이 문제를 해결하는 데 얼마나 오랜 시간이 걸리는지를 분석하는 것과 같다.

- 시간복잡도에서 중요한 것은 정해진 표현식에 가장 큰 영향을 미치는 n의 단위이다.

- 문제를 해결하려고 할 때마다 시간복잡도를 분석하는 습관을 들이면 좋은 개발자가 될 수 있다.

- 엔지니어에게 있어서, 문제라는 것은 정답이나 최선의 답의 관점에서 접근하는 것보다, 상황에 더 맞는 답인지 아닌지의 관점에서 접근해야 한다.

<br>

## Big-O notation

- **<u>BETTER</u>**
- O(1) (constant, 상수 시간)
  - 데이터 양과 상관없이 일정한 실행 시간을 가진다.
  - 문제를 해결하는 데에 오직 한 단계만 거친다.
  - 요소들의 개수를 미리 알고 있고 변화가 없다면, 상수 시간에 이루어진다고 할 수 있다.
  - 객체에서 키를 알거나, 배열에서 인덱스를 알고 있으면, 언제나 한 단계만 걸린다.
- O(log n) (logarithmic, 로그 시간)
  - 문제를 해결하는 데에 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.
  - 이진트리에서의 연산. 이진 탐색.
  - 문자열을 절반으로 쪼개어 그 오른쪽의 문자열을 다시 또 절반으로 쪼개고, 이를 반복하는 알고리즘이다.
- O(n) (linear, 직선적 시간, 선형 시간)
  - 데이터 양에 따라 시간이 정비례한다.
  - 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가진다.
  - for 문을 통한 탐색. 내부를 탐색하는 메소드가 한 번 사용될 때.
- O(n^2) (quadratic, 2차 시간)
  - 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다.
  - 데이터 양에 따라 걸리는 시간은 제곱에 비례한다.
  - 효율이 좋지 않으니 사용하면 안 된다.
  - 2중 for 문을 사용하는 버블 소트. 삽입 정렬. 내부를 탐색하는 메소드가 두 번 사용될 때.
- O(2^n) (exponential, 지수 시간)
  - 문제를 해결하기 위한 단계의 수는 주어진 상수값 C의 n제곱이다.
  - 지수 시간은 보통 문제를 풀기 위해 모든 조합과 방법을 시도할 때 사용한다.
  - 데이터 양이 조금만 늘어나도 실용적이지 않은 수행 시간을 보인다.
  - 재귀를 사용할 때.


- **<u>WORSE</u>**

<br>

## 시간복잡도 계산

- 입력값 n이 **16**일 때
  - O(1) = **1 step** (시간복잡도가 1)
  - O(log n) = **4 step** (시간복잡도가 4)
  - O(n) = **16 step** (시간복잡도가 16)
  - O(n^2) = **256 step** (시간복잡도가 256)
  - O(2^n) = **65,536 step** (...)

<br>

