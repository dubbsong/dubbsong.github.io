---
layout: post
title: "코딩을 지탱하는 기술"
categories: dev
tags: books
---

## 코딩을 지탱하는 기술

###### 니시오 히로카즈 저 | 김완섭 역

<br>

#### 시작하며

- 변화하고 있는 지식을 꾸준히 습득하지 않으면, 이미 학습한 지식도 점점 가치를 잃게 된다.
- 학습의 3가지 중요한 포인트
  - 비교를 통한 학습: 다수의 언어를 비교
  - 역사를 통한 학습: 언어의 발달 과정
  - 만드는 것을 통한 학습: 언어 설계자의 의도 파악
- 이 책의 목적은 '왜'를 해결하는 것이다.

<br>

## 1장 효율적으로 언어 배우기

<br>

### 비교를 통한 배움

- 많은 언어에서 공통적으로 사용되는 개념이 중요한 지식이다.

<br>

#### C언어와 Ruby의 참거짓 값

- C언어를 배운 사람은 '`0이 거짓이고, 그 이외의 값은 참이다`'라고 알고 있다.
- Ruby를 공부해보면 '`Ruby에서는 0이 참이다`'라는 것을 알 수 있다.

```c
// C언어에서는 0이 거짓이기 때문에 false를 출력한다.

#include <stdio.h>

int main() {
   if (0) {
      print("true!\n");
   } else {
      print("false!\n");
   }
}
```

<br>

```ruby
# Ruby에서는 0이 참이기 때문에 true를 출력한다.

if 0 then
   print "true!"
else
   print "false!"
end
```

<br>

#### Java의 참거짓 값

- Java에서는 참거짓 값을 위한 형을 가지고 있어서 조건식에서도 그 형을 사용하지 않으면 안 된다.
- 0은 정수형을 의미하기 때문에 조건식에 0을 사용하게 되면 컴파일 에러가 발생한다.
- **즉, 세상에는 0이 참인 언어, 0이 거짓인 언어, 0이 참도 거짓도 아닌 언어가 존재하고 있는 것이다.**

<br>

### 역사를 통한 배움

<br>

#### 언어 설계자의 의도를 이해하자

- 언어 설계자는 어떤 문제를 해결하기 위해 그 언어를 만든 것일까?
- 그 언어가 어떤 흐름을 따라 만들어졌는지 알게 되면 그 기능이 왜 필요한지 납득할 수 있게 된다.

<br>

#### 어떤 언어를 배워야 하는지는 아무도 모른다

- '프로그래밍을 배우고 싶은데 어떤 언어를 배우면 좋을까?'라는 질문은 무의미하다.

<br>

#### 언어에 의존하지 않는 보편적인 지식의 습득

- 언어가 바뀌어도 통용할 수 있는 이해력을 기를 필요가 있다.

<br>

### 정리

- 이 책은 보다 보편적인 지식을 습득할 수 있도록 하고 있다.
- 다수의 언어를 비교해 가면서 학습한다.
- 언어가 어떻게 바뀌었고, 바뀌기 전에는 어떤 의문점이 존재했는지 학습한다.

------

<br>

## 2장 프로그래밍 언어를 조감하다

<br>

### 프로그래밍 언어 탄생의 역사

- 많은 것이 과거의 것을 발전시켜 만들어졌다.

> 프로그래밍 언어는 어떻게 탄생한 것일까?
>
> 프로그래밍 언어를 만든 목적은 무엇일까?
>
> 옛날 언어와 지금 언어의 공통점은 무엇일까?

- 프로그래밍 언어는 인간을 편하게 하기 위해 만들어졌다.

<br>

#### 케이블을 연결하다

- 1946년에 ENIAC(Electronic Numerical Integrator and Computer)이 발명됐다. 이 컴퓨터는 '무엇을 계산할지', 즉 목적에 따라 프로그램을 변경할 수 있었다. '프로그래밍'이 가능한 컴퓨터이나 그 방법은 지금의 프로그래밍과는 매우 달랐다.
- ENIAC은 17,468개의 진공관을 사용한 거대한 컴퓨터로, 그 폭은 24미터나 됐다. 25미터 수영장에 진공관이 엄청나게 붙어있는 커다란 기계가 줄 서 있는 상황을 상상해보자.
- 이 컴퓨터의 수많은 단자에 케이블을 여기저기 연결하는 것이 프로그래밍이었다. 좀 더 편하게 할 수는 없었을까?

<br>

#### 프로그램 내장 방식으로

- 1949년 EDSAC(Electronic Delay Storage Automatic Calculator)이 개발됐다. 이것은 테이프에 구멍을 뚫어서 데이터를 표현하고, 컴퓨터가 이를 읽어 들이도록 한 구조다. 물리적 케이블을 교환하는 대신, 종이 테이프의 데이터를 읽어 들여서 프로그램을 변경할 수 있었다. 이것으로 변경 작업이 한결 수월해졌다.
- 수월해졌다고는 하지만, 사람이 프로그램을 읽거나 쓰는 것은 여전히 어려웠다. 어디까지나 기계가 읽기 위한 언어, 즉 '`기계어`'였던 것이다.

<br>

#### FORTRAN의 등장

- 1954년, 현재와 비슷한 프로그래밍 언어가 고안되었다. 바로 FORTRAN이다.
- FORTRAN이란 이름은 Formula Translating System(수식 변환 시스템)을 의미한다.
- `x * y + z`라고 최초로 표현한 것이 FORTRAN이다.
- 수식을 기계어로 변환하는 것이 FORTRAN의 특징 중 하나였다.
- 효율이 높은 프로그램을 위해서는 사람이 기계어를 쓰는 수밖에 없다고 생각했다. FORTRAN 컴파일러가 출력하는 기계어는 효율은 떨어지지만 코드량이 눈에 띄게 줄었고, 코드를 읽기 쉬워짐에 따라 많은 사용자층을 얻을 수 있었다.
- FORTRAN의 설계자인 John Backus는 다음과 같이 말했다.

> 내가 이룬 성과의 대부분은 나태함에서 오고 있다.
>
> 나는 프로그램 짜는 것을 좋아하지 않았다.
>
> 그래서 프로그램을 쉽게 짤 수 있는 시스템을 만들었다.

<br>

### 프로그래밍 언어 탄생의 목적

- 프로그램은 어떤 것을 편하게 하기 위해 고안된 것이다.
- 편하게 하는 것은 부실하게 하는 것과는 다르다.
- 부실하게 만들어서 나중에 고생케 하는 것은 편하게 만들었다고 볼 수 없다.

<br>

#### 나태 (Laziness)

- 전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질.
- 이는 프로그래머에게 있어 가장 중요한 자질이기도 하다.
- 당장에 눈에 보이는 편리함을 요구하는 것이 아니라, 앞날까지 생각해서 가장 편한 방법을 선택하는 것이다.
- 즉, 같은 성과를 달성하는 다수의 방법 중 가장 생산성이 높은 것을 선택함을 의미한다.

<br>

#### 무엇을 편하게 하고 싶은 것인가?

- C++은 빠른 실행 속도를 중시하고 있는 언어이다. C로 만든 코드보다 빠른 속도가 날 수 있도록 고안했지만, 결과적으로 언어 사양이 더 복잡해지고 말았다.
- Scheme은 언어 사양을 쉽게 파악할 수 있는 데 중점을 두고 있는 언어이다. 그러나 구문이 수많은 괄호로 이루어져 있어서 싫어하는 사람도 많다.

<br>

#### 어떤 프로그램을 편하게 만들고 싶은가?

- Python은 다른 사람이 쓴 코드를 쉽게 해석할 수 있는 데 중점을 두고 있는 언어이다. 하지만 속도가 느리며, 사양도 단순하지 않다.
- PHP는 웹 서비스를 쉽게 만들 수 있도록 해준다. 그러나 문장 처리를 편하게 하지는 못한다.
- 올바른 설계는 사용하는 사람이 무엇을 목적으로 하고 있는지에 따라 달라진다.
- **다양한 설계 언어가 있는 것은 사람에 따라 다양한 목적이 있기 때문이다.**

<br>

### 정리

- 프로그래밍 언어는 사람을 편하게 하기 위해 만들어졌다. 그러나 무엇이 편한지는 언어에 따라 다르다.
- 언어는 도구이다. 어떤 언어가 자신의 목적에 적합한지는 그 언어를 사용할 때 자신이 어느 정도의 생산성을 발휘할 수 있는지로 판단할 수 있다.
- 다른 사람이 말하는 것에 혹하지 말고, **좋은 도구를 현명하게 선택하여 적재적소에 사용하도록 하자.**

<br>

## 3장 문법의 탄생

<br>

### 문법이란?

- 문법이란, 프로그래밍 언어 설계자가 만든 '이렇게 쓰면 이런 의미로 해석된다'라고 정한 규칙이다.
- FORTH라는 언어는 문법이 거의 없다.
- LISP라는 언어는 괄호로 코드 구조를 표현한다.


- 언어 설계자가 정한 규칙이 바로 문법이다. 문법은 언어에 따라 다르다. 연산자의 종류도 언어에 따라 다르다.

<br>

### 스택 머신과 FORTH

- FORTH는 1958년 경에 개발되어 문법이 거의 존재하지 않는 언어이다.

<br>

#### 계산 순서

- FORTH의 가장 큰 특징인 '`스택(Stack)`', 즉 '`값을 쌓아두는 장소`'를 사용한다.
- 거의 한국어 어순 그대로이다.
- FORTH에서는 괄호도 '우선순위라는 규칙'도 도입하지 않고 표현한다.


- FORTH에서는 '`1과 2를 더한다`'는 코드를 다음과 같이 쓴다.

```javascript
1 2 +
```

<br>

- '`1과 2를 더한 것에 3을 곱한다`'는 코드는 다음과 같이 쓴다.

```javascript
1 2 + 3 *
```

<br>

- '`2와 3을 곱한 후 1을 더한다`'는 코드는 다음과 같이 쓴다.

```javascript
2 3 * 1 +
```

<br>

#### 현재도 살아있는 스택 머신

- Java, Python, Ruby 1.9 등은 스택 머신(Stack machine) 형의 VM을 사용하고 있다.
- Java, Python, Ruby로 프로그램을 짜면 그 프로그램은 내부적으로 FORTH와 같은 프로그램으로 변환(컴파일)되어 동작하고 있는 것이다.

<br>

### 구문 트리와 LISP

- '하나의 구역을 표현하기 위해 항상 괄호를 사용하자'는 선택을 한 언어가 1958년에 탄생한 LISP이다.

<br>

#### 계산의 흐름

- LISP로 '`1과 2를 더한다`'는 코드는 다음과 같이 쓴다.

```javascript
(+ 1 2)
```

<br>

#### 계산 순서를 어떻게 표현할까?

- '`1과 2를 더한 후 3을 곱한다`'는 코드는 다음과 같이 쓴다.

```javascript
(* (+ 1 2) 3)
```

<br>

- FORTH나 LISP는 특정 규칙을 사용해 구문 트리를 모방한 것이다.

<br>

#### 현재도 살아있는 구문 트리

- Python에 기본으로 장착되어 있는 `ast`(abstract syntax tree, 추상 구문 트리) 라이브러리를 사용하면 특정 코드가 어떤 구문 트리로 구성되어 있는지 알 수 있다.

```python
>>> import ast
>>> ast.dump(ast.parse("1 + 2"))
Module(
	body=[Expr(
   	value=BinOp(
      	left=Num(n=1),
         op=Add(),
         right=Num(n=2))
   	)
	]
)

>>> ast.dump(ast.parse("(1 + 2) * 3"))
Module(
	body=[Expr(
   	value=BinOp(
      	left=BinOp(
         	left=Num(n=1),
            op=Add(),
            right=Num(n=2)
         ),
         op=Mult(),
         right=Num(n=3))
   	)
	]
)
```

- `Binop op=Mult()`는 '곱셈'을 의미하고, LISP의 '*'에 대응된다.
- `Binop op=Add()`는 '덧셈'을 의미하고, LISP의 '+'에 대응된다.
- `Num n=1`은 '수치1'로, LISP의 '1'에 대응된다.

<br>

### 중위 표기법

- 연산자를 연산 대상 뒤에 두는 것을 `후위 표기법`, 앞에 두는 것을 `전위 표기법`, 사이에 두는 것을 `중위 표기법`이라고 한다.
- FORTRAN은 연산자 우선순위나 결합성 등 다양한 규칙을 도입해 문법을 만들었다.

<br>

#### 구문 해석기

- 구문 해석기(Parser, 파서)는 소스 코드를 문자열로 읽어 들여 해석하고, 그것을 구문 트리로 만드는 프로그램이다.
- 문법 설계와 구문 분석기 구현은 프로그래밍 언어의 외관을 결정하는 중요한 요소이다.
- 구문 분석 방법에 따라서 어떤 규칙을 적용해야 애매한 부분 없이 분석할 수 있는지가 달라지게 된다.
- 이미 만든 언어에 새로운 기능을 추가할 때는 기존 규칙과 맞지 않아 문제를 일으키는 경우도 있다.

<br>

#### 규칙간 마찰

- 예를 들어 C++에서는 템플릿 기능을 추가할 때 vector\<int>와 같이 '부등호로 감싸는 표기'를 도입했다. 그러나 이 부등식 괄호를 이중으로 하면 괄호를 닫는 >>가 기존의 '쉬프트(shift) 연산자'로 해석되어 버린다. 이 문제를 구문 분석기에서 해결하는 것이 쉽지 않아서 프로그래머가 공백 문자를 사이에 입력해서 >>가 되지 않도록 하는, 즉 운영 측면에서 문제를 해결하도록 했다.

```c++
// OK
vector<vector<int> > x;

// NG
vector<vector<int>> y;
```

<br>

- 다른 언어에도 과거 규칙과의 마찰로 인해 부자연스러운 규칙이 생겨난 경우가 있다.

<br>

### 정리

- 프로그램을 짤 대 '왜 이렇게 다가가기 어려운 작성법이 필요한지' 생각한 적이 있을 것이다.
- 현재 대부분의 프로그래밍 언어는 FORTRAN 식의 '다가가기 쉬운 작성법'을 목표로 하고 있다.
- 모순 없이 해석할 수 있는 문법을 만들어내는 것은 어려운 작업이다.
- 특히 나중에 새로운 문법을 추가할 때 기존 문법과 마찰되지 않도록 하는 것은 더욱 어렵다.

<br>

## 4장 처리 흐름 제어

<br>

### 구조화 프로그래밍의 탄생

- ​











<br>

> 칼럼 | 이해력을 확인하기 위해서는 결과물(Output)을 확인한다
>
> 이해한 것이 맞는지를 확인하기 위해서는 결과물(Output)이 필요하다.
>
> 프로그래머는 이런 점에서는 혜택을 받고 있다.
>
> 프로그래밍 언어의 결과물은 언어 처리계가 틀린 곳을 자세히 지적해준다.
>
> 에러 메시지를 이해하려 하지 않고서는 언어 처리계와 제대로된 커뮤니케이션을 할 수가 없다.

<br>

> 칼럼 | 무엇을 배우면 좋을지 모르는 이유
>
> '무엇을 배우면 좋을까?'라는 질문에 대답하기 전에 한 가지 물어보고 싶다.
>
> '무엇을 만들고 싶은가?'
>
> 목적이 명확하지 않으면 최선의 방법 또한 가르쳐줄 수 없다.
>
> '무엇을 배울지, 무엇을 배우면 좋을지'를 정할 때 필연적으로 지표가 될 수 있는 것이
>
> '무엇을 만들고 싶은가?', 즉 목적을 명확히 하는 것이다.
>
> 그리고 목적을 달성하기 위해 필요한 것부터 배우면 된다.
>
> '무엇을 만들까?'를 결정할 수 없다면, 처음부터 완벽한 것을 만들려고 하는 것은 아닌지 고민해보자.
>
> 처음부터 굉장한 것을 만들려고 생각해서 오히려 손도 대지 못하고 있다면,
>
> 시간이 흘러도 굉장한 것을 만들 수 없다.
>
> 이 과정을 반복해가면 보다 복잡한 것을 만드는 능력이 몸에 베게 된다.

<br>

