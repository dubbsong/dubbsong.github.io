---
layout: post
title: "코딩을 지탱하는 기술"
categories: dev
tags: books
---

###### 니시오 히로카즈 저 | 김완섭 역

<br>

#### 시작하며

- 변화하고 있는 지식을 꾸준히 습득하지 않으면, 이미 학습한 지식도 점점 가치를 잃게 된다.
- 학습의 3가지 중요한 포인트
  - 비교를 통한 학습: 다수의 언어를 비교
  - 역사를 통한 학습: 언어의 발달 과정
  - 만드는 것을 통한 학습: 언어 설계자의 의도 파악
- 이 책의 목적은 '왜'를 해결하는 것이다.

<br>

## 1장 효율적으로 언어 배우기

<br>

### 비교를 통한 배움

- 많은 언어에서 공통적으로 사용되는 개념이 중요한 지식이다.

<br>

#### C언어와 Ruby의 참거짓 값

- C언어를 배운 사람은 '`0이 거짓이고, 그 이외의 값은 참이다`'라고 알고 있다.
- Ruby를 공부해보면 '`Ruby에서는 0이 참이다`'라는 것을 알 수 있다.

```c
// C언어에서는 0이 거짓이기 때문에 false를 출력한다.

#include <stdio.h>

int main() {
   if (0) {
      print("true!\n");
   } else {
      print("false!\n");
   }
}
```

<br>

```ruby
# Ruby에서는 0이 참이기 때문에 true를 출력한다.

if 0 then
   print "true!"
else
   print "false!"
end
```

<br>

#### Java의 참거짓 값

- Java에서는 참거짓 값을 위한 형을 가지고 있어서 조건식에서도 그 형을 사용하지 않으면 안 된다.
- 0은 정수형을 의미하기 때문에 조건식에 0을 사용하게 되면 컴파일 에러가 발생한다.
- **즉, 세상에는 0이 참인 언어, 0이 거짓인 언어, 0이 참도 거짓도 아닌 언어가 존재하고 있는 것이다.**

<br>

### 역사를 통한 배움

<br>

#### 언어 설계자의 의도를 이해하자

- 언어 설계자는 어떤 문제를 해결하기 위해 그 언어를 만든 것일까?
- 그 언어가 어떤 흐름을 따라 만들어졌는지 알게 되면 그 기능이 왜 필요한지 납득할 수 있게 된다.

<br>

#### 어떤 언어를 배워야 하는지는 아무도 모른다

- '프로그래밍을 배우고 싶은데 어떤 언어를 배우면 좋을까?'라는 질문은 무의미하다.

<br>

#### 언어에 의존하지 않는 보편적인 지식의 습득

- 언어가 바뀌어도 통용할 수 있는 이해력을 기를 필요가 있다.

<br>

### 정리

- 이 책은 보다 보편적인 지식을 습득할 수 있도록 하고 있다.
- 다수의 언어를 비교해 가면서 학습한다.
- 언어가 어떻게 바뀌었고, 바뀌기 전에는 어떤 의문점이 존재했는지 학습한다.

------

<br>

## 2장 프로그래밍 언어를 조감하다

<br>

### 프로그래밍 언어 탄생의 역사

- 많은 것이 과거의 것을 발전시켜 만들어졌다.

> 프로그래밍 언어는 어떻게 탄생한 것일까?
>
> 프로그래밍 언어를 만든 목적은 무엇일까?
>
> 옛날 언어와 지금 언어의 공통점은 무엇일까?

- 프로그래밍 언어는 인간을 편하게 하기 위해 만들어졌다.

<br>

#### 케이블을 연결하다

- 1946년에 ENIAC(Electronic Numerical Integrator and Computer)이 발명됐다. 이 컴퓨터는 '무엇을 계산할지', 즉 목적에 따라 프로그램을 변경할 수 있었다. '프로그래밍'이 가능한 컴퓨터이나 그 방법은 지금의 프로그래밍과는 매우 달랐다.
- ENIAC은 17,468개의 진공관을 사용한 거대한 컴퓨터로, 그 폭은 24미터나 됐다. 25미터 수영장에 진공관이 엄청나게 붙어있는 커다란 기계가 줄 서 있는 상황을 상상해보자.
- 이 컴퓨터의 수많은 단자에 케이블을 여기저기 연결하는 것이 프로그래밍이었다. 좀 더 편하게 할 수는 없었을까?

<br>

#### 프로그램 내장 방식으로

- 1949년 EDSAC(Electronic Delay Storage Automatic Calculator)이 개발됐다. 이것은 테이프에 구멍을 뚫어서 데이터를 표현하고, 컴퓨터가 이를 읽어 들이도록 한 구조다. 물리적 케이블을 교환하는 대신, 종이 테이프의 데이터를 읽어 들여서 프로그램을 변경할 수 있었다. 이것으로 변경 작업이 한결 수월해졌다.
- 수월해졌다고는 하지만, 사람이 프로그램을 읽거나 쓰는 것은 여전히 어려웠다. 어디까지나 기계가 읽기 위한 언어, 즉 '`기계어`'였던 것이다.

<br>

#### FORTRAN의 등장

- 1954년, 현재와 비슷한 프로그래밍 언어가 고안되었다. 바로 FORTRAN이다.
- FORTRAN이란 이름은 Formula Translating System(수식 변환 시스템)을 의미한다.
- `x * y + z`라고 최초로 표현한 것이 FORTRAN이다.
- 수식을 기계어로 변환하는 것이 FORTRAN의 특징 중 하나였다.
- 효율이 높은 프로그램을 위해서는 사람이 기계어를 쓰는 수밖에 없다고 생각했다. FORTRAN 컴파일러가 출력하는 기계어는 효율은 떨어지지만 코드량이 눈에 띄게 줄었고, 코드를 읽기 쉬워짐에 따라 많은 사용자층을 얻을 수 있었다.
- FORTRAN의 설계자인 John Backus는 다음과 같이 말했다.

> 내가 이룬 성과의 대부분은 나태함에서 오고 있다.
>
> 나는 프로그램 짜는 것을 좋아하지 않았다.
>
> 그래서 프로그램을 쉽게 짤 수 있는 시스템을 만들었다.

<br>

### 프로그래밍 언어 탄생의 목적

- 프로그램은 어떤 것을 편하게 하기 위해 고안된 것이다.
- 편하게 하는 것은 부실하게 하는 것과는 다르다.
- 부실하게 만들어서 나중에 고생케 하는 것은 편하게 만들었다고 볼 수 없다.

<br>

#### 나태 (Laziness)

- 전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질.
- 이는 프로그래머에게 있어 가장 중요한 자질이기도 하다.
- 당장에 눈에 보이는 편리함을 요구하는 것이 아니라, 앞날까지 생각해서 가장 편한 방법을 선택하는 것이다.
- 즉, 같은 성과를 달성하는 다수의 방법 중 가장 생산성이 높은 것을 선택함을 의미한다.

<br>

#### 무엇을 편하게 하고 싶은 것인가?

- C++은 빠른 실행 속도를 중시하고 있는 언어이다. C로 만든 코드보다 빠른 속도가 날 수 있도록 고안했지만, 결과적으로 언어 사양이 더 복잡해지고 말았다.
- Scheme은 언어 사양을 쉽게 파악할 수 있는 데 중점을 두고 있는 언어이다. 그러나 구문이 수많은 괄호로 이루어져 있어서 싫어하는 사람도 많다.

<br>

#### 어떤 프로그램을 편하게 만들고 싶은가?

- Python은 다른 사람이 쓴 코드를 쉽게 해석할 수 있는 데 중점을 두고 있는 언어이다. 하지만 속도가 느리며, 사양도 단순하지 않다.
- PHP는 웹 서비스를 쉽게 만들 수 있도록 해준다. 그러나 문장 처리를 편하게 하지는 못한다.
- 올바른 설계는 사용하는 사람이 무엇을 목적으로 하고 있는지에 따라 달라진다.
- **다양한 설계 언어가 있는 것은 사람에 따라 다양한 목적이 있기 때문이다.**

<br>

### 정리

- 프로그래밍 언어는 사람을 편하게 하기 위해 만들어졌다. 그러나 무엇이 편한지는 언어에 따라 다르다.
- 언어는 도구이다. 어떤 언어가 자신의 목적에 적합한지는 그 언어를 사용할 때 자신이 어느 정도의 생산성을 발휘할 수 있는지로 판단할 수 있다.
- 다른 사람이 말하는 것에 혹하지 말고, **좋은 도구를 현명하게 선택하여 적재적소에 사용하도록 하자.**

------

<br>

## 3장 문법의 탄생

<br>

### 문법이란?

- 문법이란, 프로그래밍 언어 설계자가 만든 '이렇게 쓰면 이런 의미로 해석된다'라고 정한 규칙이다.
- FORTH라는 언어는 문법이 거의 없다.
- LISP라는 언어는 괄호로 코드 구조를 표현한다.


- 언어 설계자가 정한 규칙이 바로 문법이다. 문법은 언어에 따라 다르다. 연산자의 종류도 언어에 따라 다르다.

<br>

### 스택 머신과 FORTH

- FORTH는 1958년 경에 개발되어 문법이 거의 존재하지 않는 언어이다.

<br>

#### 계산 순서

- FORTH의 가장 큰 특징인 '`스택(Stack)`', 즉 '`값을 쌓아두는 장소`'를 사용한다.
- 거의 한국어 어순 그대로이다.
- FORTH에서는 괄호도 '우선순위라는 규칙'도 도입하지 않고 표현한다.


- FORTH에서는 '`1과 2를 더한다`'는 코드를 다음과 같이 쓴다.

```javascript
1 2 +
```

<br>

- '`1과 2를 더한 것에 3을 곱한다`'는 코드는 다음과 같이 쓴다.

```javascript
1 2 + 3 *
```

<br>

- '`2와 3을 곱한 후 1을 더한다`'는 코드는 다음과 같이 쓴다.

```javascript
2 3 * 1 +
```

<br>

#### 현재도 살아있는 스택 머신

- Java, Python, Ruby 1.9 등은 스택 머신(Stack machine) 형의 VM을 사용하고 있다.
- Java, Python, Ruby로 프로그램을 짜면 그 프로그램은 내부적으로 FORTH와 같은 프로그램으로 변환(컴파일)되어 동작하고 있는 것이다.

<br>

### 구문 트리와 LISP

- '하나의 구역을 표현하기 위해 항상 괄호를 사용하자'는 선택을 한 언어가 1958년에 탄생한 LISP이다.

<br>

#### 계산의 흐름

- LISP로 '`1과 2를 더한다`'는 코드는 다음과 같이 쓴다.

```javascript
(+ 1 2)
```

<br>

#### 계산 순서를 어떻게 표현할까?

- '`1과 2를 더한 후 3을 곱한다`'는 코드는 다음과 같이 쓴다.

```javascript
(* (+ 1 2) 3)
```

<br>

- FORTH나 LISP는 특정 규칙을 사용해 구문 트리를 모방한 것이다.

<br>

#### 현재도 살아있는 구문 트리

- Python에 기본으로 장착되어 있는 `ast`(abstract syntax tree, 추상 구문 트리) 라이브러리를 사용하면 특정 코드가 어떤 구문 트리로 구성되어 있는지 알 수 있다.

```python
>>> import ast
>>> ast.dump(ast.parse("1 + 2"))
Module(
	body=[Expr(
   	value=BinOp(
      	left=Num(n=1),
         op=Add(),
         right=Num(n=2))
   	)
	]
)

>>> ast.dump(ast.parse("(1 + 2) * 3"))
Module(
	body=[Expr(
   	value=BinOp(
      	left=BinOp(
         	left=Num(n=1),
            op=Add(),
            right=Num(n=2)
         ),
         op=Mult(),
         right=Num(n=3))
   	)
	]
)
```

- `Binop op=Mult()`는 '곱셈'을 의미하고, LISP의 '*'에 대응된다.
- `Binop op=Add()`는 '덧셈'을 의미하고, LISP의 '+'에 대응된다.
- `Num n=1`은 '수치1'로, LISP의 '1'에 대응된다.

<br>

### 중위 표기법

- 연산자를 연산 대상 뒤에 두는 것을 `후위 표기법`, 앞에 두는 것을 `전위 표기법`, 사이에 두는 것을 `중위 표기법`이라고 한다.
- FORTRAN은 연산자 우선순위나 결합성 등 다양한 규칙을 도입해 문법을 만들었다.

<br>

#### 구문 해석기

- 구문 해석기(Parser, 파서)는 소스 코드를 문자열로 읽어 들여 해석하고, 그것을 구문 트리로 만드는 프로그램이다.
- 문법 설계와 구문 분석기 구현은 프로그래밍 언어의 외관을 결정하는 중요한 요소이다.
- 구문 분석 방법에 따라서 어떤 규칙을 적용해야 애매한 부분 없이 분석할 수 있는지가 달라지게 된다.
- 이미 만든 언어에 새로운 기능을 추가할 때는 기존 규칙과 맞지 않아 문제를 일으키는 경우도 있다.

<br>

#### 규칙간 마찰

- 예를 들어 C++에서는 템플릿 기능을 추가할 때 vector\<int>와 같이 '부등호로 감싸는 표기'를 도입했다. 그러나 이 부등식 괄호를 이중으로 하면 괄호를 닫는 >>가 기존의 '쉬프트(shift) 연산자'로 해석되어 버린다. 이 문제를 구문 분석기에서 해결하는 것이 쉽지 않아서 프로그래머가 공백 문자를 사이에 입력해서 >>가 되지 않도록 하는, 즉 운영 측면에서 문제를 해결하도록 했다.

```c++
// OK
vector<vector<int> > x;

// NG
vector<vector<int>> y;
```

<br>

- 다른 언어에도 과거 규칙과의 마찰로 인해 부자연스러운 규칙이 생겨난 경우가 있다.

<br>

### 정리

- 프로그램을 짤 대 '왜 이렇게 다가가기 어려운 작성법이 필요한지' 생각한 적이 있을 것이다.
- 현재 대부분의 프로그래밍 언어는 FORTRAN 식의 '다가가기 쉬운 작성법'을 목표로 하고 있다.
- 모순 없이 해석할 수 있는 문법을 만들어내는 것은 어려운 작업이다.
- 특히 나중에 새로운 문법을 추가할 때 기존 문법과 마찰되지 않도록 하는 것은 더욱 어렵다.

------

<br>

## 4장 처리 흐름 제어

<br>

### 구조화 프로그래밍의 탄생

- 1960년대 후반, '사람이 프로그램을 보다 편하게 쓰고 읽을 수 있도록 규칙을 만들자'는 흐름을 타고 '`구조화 프로그래밍`'이 태어났다.
- `if 문`이나 `while 문` 등의 규칙(구문)을 도입하여 코드 구조를 쉽게 만들자는 생각이었다.


<br>

#### if는 왜 있는 걸까?

- 어셈블리어에는 if 문이 없다. 그러나 어셈블리어는 C언어에서 간단히 변환(컴파일)된다.
- 'x가 456과 같으면 처리한다'는 코드

```c
// C언어

int main() {
   int x = 123;
   /* if 문 앞*/
   if (x == 456) {
      /* if 문 안*/
   }
   /* if 문 뒤*/
}
```

<br>

- 컴파일하면 다음과 같은 어셈블리어 코드가 출력된다.

```assembly
// 어셈블리어

_main:
	......
	mov1	$123, -8(%rbp)
	# if 문 앞
	mov1	-8(%rbp), %eax
	cmp1	$456, %eax
	jne	LBB1_2
	# if 문 안
LBB1_2:
	# if 문 뒤
	......
```

- `-8(%rbp)`는 원래 코드의 x라고 해석한다.
- `mov1 $123, -8(%rbp)`에서는 x에 수치 123을 대입한다.
- `mov1 -8(%rbp), %eax`에서는 x의 값을 %eax라는 임시 저장소에 이동 후 수치 456과 비교한다.
- `jne LBB1_2`은 '바로 직전 비교에서 양쪽이 동일하지 않으면 LBB1_2로 점프'하라는 명령이다.
- '조건을 만족하면 점프'라는 명령은 꽤 초기부터 존재했다.

<br>

#### if-else 사용의 장점

- '조건이 참인 경우와 거짓인 경우의 처리 흐름을 분배한다'는 패턴은 프로그래밍에 빈번히 사용된다.
- 프로그래밍을 하면서 else가 반드시 필요한 건 아니다.
- else는 더 편하게 사용할 수 있고, 더 편하게 읽을 수 있다.

<br>

### while, 반복되는 if를 읽기 쉽게 표현

- while 문은 '조건을 만족하고 있는 동안 블럭 안의 내용을 반복하여 실행'하는 구문이다.

<br>

#### while 문을 사용하는 방법

- 조건 `x > 0`을 만족하고 있는 동안 '`x를 표시하고 x에서 1을 뺀다`'는 처리를 반복한다.

```c
// C언어

void use_while(int x) {
   printf("use_while\n");
   while(x > 0) {
      printf("%d\n", x);
      x--;
   }
}
```

<br>

#### while 문을 사용하지 않는 방법

- '`조건을 만족하지 않으면 END_LOOP에 점프`', '`x를 표시하고 x에서 1을 뺀다`', '`조건문 직전으로 점프한다`'는 코드

```c
// C언어

void not_use_while(int x) {
   printf("not_use_while\n");
}
```

<br>

- 많은 언어들이 루프(Loop)를 중단하는 break 문을 가지고 있다.
- break 문을 실행하면 바로 루프를 빠져나간다.
- 이것은 goto END_LOOP와 같은 동작이다.
- while 문이 가져온 편리함은 '새로운 것'이 아니라, '`읽기 쉽게 함`', '`쓰기 쉽게 함`'인 것이다.
- goto는 강력하고 이해하기 쉬운 개념이다. 그러나 너무 원시적이다.
- if-else나 while, break는 '제한이 붙은 goto'라고 생각하면 된다.

<br>

### for, 수치를 증가시키는 while을 읽기 쉽게 표현

- for 문으로 할 수 있는 것은 while 문으로도 가능하다.

<br>

#### for를 사용하는 방법

- i를 0이상 N 미만의 범위에서 1씩 증가시키며 표시하는 코드

```c
// C언어

for (i = 0; i < N; i++) {
   printf("%d\n", i);
}
```

<br>

#### for를 사용하지 않는 방법

- i를 0이상 N 미만의 범위에서 1씩 증가시키며 표시하는 코드

```c
// C언어

i = 0;
while (i < N) {
   printf("%d\n", i);
   i++;
}
```

<br>

#### foreach, 처리 대상으로 반복 제어

- for 문이 다시 한 번 진화한 것이 foreach 구문이다.
- Java에서는 확장 for 문이라고 불리고 있지만, Perl, PHP, C# 등 많은 언어에서 foreach라는 이름으로 불리고 있다.
- **while은 조건식으로 반복을 제어**한다. **for는 횟수로 반복을 제어**한다. **foreach는 처리 대상으로 반복을 제어**한다.
- foreach 구문은 '어떤 대상의 요소 전부에 어떤 처리를 한다'는 코드를 쉽게 쓰기 위해 만들어졌다.

```java
// Java

// 배열
int[] items = new int[]{1, 2, 3, 4, 5};


// 일반 for 문으로 각 요소를 출력
for (int i = 0; i < items.length; i++) {
   int item = items[i];
   System.out.println(item);
}


// 확장 for 문으로 각 요소를 출력
for (int item: items) {
   System.out.println(item);
}
```

- for 문에서는 '0 이상 items 크기 미만의 범위에서 i를 1씩 증가시키면서 items의 i번째를 표시'라고 표현한다.
- foreach 구문에서는 'items의 각 요소를 표시'라고 간단하게 쓰고 있다.

<br>

### 정리

- if 문, while 문, for 문을 사용하지 않아도 프로그램을 짤 수 있다.
- 그러나 사용하는 것이 보다 알기 쉬운 코드를 구성할 수 있다.

------

<br>

## 5장 함수

<br>

### 함수의 역할

- 함수는 '코드의 일부를 한 덩어리로 잘라내어 그것에 이름을 붙이는 기능'이다.
- 함수가 없어도 구현할 수 있지만, 함수를 사용하는 게 보다 편한 경우가 있다.

<br>

#### 이해

- 코드가 함수로 나눠져 있는 것은 큰 조직이 부서로 나눠져 있는 것과 닮았다.
- 소스 코드의 행수가 많아지면 전체를 파악하기 어렵게 된다.
- 그래서 몇 개의 행을 하나의 그룹으로 묶어서 거기에 이름을 붙이는 것이다. 이것이 함수다.

<br>

#### 재사용

- 함수를 만드는 것은 작은 부품을 조립해서 큰 부품을 만드는 것과 비슷하다.
- 수십 행, 수백 행의 코드가 함수로 정리되어 제공되고 있어서 쉽게 그 함수를 호출해서 사용할 수 있다.
- '전지'라는 이름으로 인해, 전지를 사용한 시스템을 간단히 이해할 수 있다. 전지의 구조를 상세히 알지 못해도 '전지는 전기를 만들어 내는 것이다'라는 지식만으로 초등학생이라도 무선 조정 자동차를 조립할 수 있다. 그리고 무선 조정 자동차가 느려지면 '전지가 약해졌다'고 생각할 수 있다. 이것은 함수가 이해를 도와주는 것과 비슷하다.

<br>

#### 프로그램 재사용의 특징

- 프로그램을 만드는 것과 물리적인 것을 만드는 것에는 크게 다른 점이 하나 있다. 그것은 부품을 재사용하고 싶을 때 드는 비용이다.
- 길게 늘려있는 명령들을 자주 사용되는 단위로 잘라내어 정리함으로써 프로그램을 보다 쉽게 이해할 수 있게 된다.

<br>

### 돌아가는 명령

- goto 문으로 못하는 것, 그것은 바로 '원래 위치로 돌아가는 것'이다.
- '원래 위치로 돌아가'라는 명령이 가능하면 코드를 재사용할 수 있게 된다.

<br>

#### 함수의 탄생

- 함수를 호출한 후 원래 위치로 돌아오는 것을 점프 명령의 목적지를 변경해서 구현했었다.

> 1: 110의 점프 명령의 점프 목적지를 3으로 바꾼다
>
> 2: 함수를 호출한다 (100으로 점프)
>
> 3: 다음 명령
>
> …...
>
> 51: 110의 점프 명령의 점프 목적지를 53으로 바꾼다
>
> 52: 함수 호출 (100으로 점프)
>
> 53: 다음 명령
>
> …...
>
> 100: 함수 처리
>
> …...
>
> 110: 돌아간다 (0으로 점프)

- 이렇게 해서 함수가 탄생했다.

<br>

#### 돌아갈 목적지를 기록하기 위한 전용 메모리

- 함수 호출 전으로 돌아가도록 하는 명령의 점프 목적지를 변경하기 위해, 함수를 호출하는 사람이 '점프 목적지가 어딘지', '돌아가는 명령이 있는 곳은 어디인지'를 상호간에 파악해둬야만 했다.
- 돌아갈 목적지를 기록해두는 전용 메모리를 만들어 '돌아갈 목적지 메모리에 적어둔 번지로 점프하는 명령'을 준비해두는 방법이다. 이것으로 호출처가 '돌아가는 명령의 위치'를 파악해둘 필요가 없어졌다.

> 1: '돌아갈 목적지 메모리'에 3을 넣는다
>
> 2: 함수 호출 (100으로 점프)
>
> 3: 다음 명령
>
> …...
>
> 100: 함수 처리
>
> …...
>
> 110: 돌아갈 목적지 메모리에 써있는 지번으로 돌아간다

- 그러나 이 방법에는 문제가 있다. 함수 X를 호출하고 있는 중에 다른 함수 Y를 호출하면, 돌아갈 목적지 메모리에 덮어 씌워져서 함수 X가 돌아갈 목적지를 잊어버리게 된다.

<br>

#### 스택

- 그래서 등장하는 것이 스택(Stack)이다.
- 스택은 복수의 값을 저장해두는 데이터 구조로, 마지막에 넣은 것을 가장 먼저 꺼내는 경우에 적합하다.

<br>

### 재귀 호출

- 재귀 호출이란 함수 X 안에서 함수 X 자신을 호출하는 것이다.

<br>

#### 내포 구조 데이터의 효율적 처리

- '어떤 처리를 하고 있는 도중에 동일한 처리를 다른 대상(인수)에 대해 실행한다'는 내포(nesting) 형태의 처리다.

<br>

#### 내포 구조를 다루는 방법

- [1, 2, [3, 4], 5]라는 리스트를 생각해보자. 이것은 [1, 2, ?, 5]라는 리스트의 ? 부분에 [3, 4]라는 별도의 리스트가 내포되어 있다. 이 내포 리스트에 있는 숫자를 전부 합산하고 싶을 때는 어떻게 하면 될까?

```python
// Python

def total(xs):
   result = 0
   for x in xs:
      # 리스트 xs에서 요소를 하나씩 꺼내 x라고 한다.
      if is_integer(x):
         # x가 정수이면 더한다.
         result += x
		else:
         # x가 리스트이기 때문에 for 문으로 돌린다.
         for y in x:
            if is_integer(y):
               result += y
		else:
         # 추가로 리스트가 나오면 어떻게 하면 좋을까?
	return result
```

- 추가로 for 문을 써도 '3중 내포까지 처리 가능한 코드' 밖에 되지 않는다.
- 만약 데이터가 4중, 5중 내포 관계가 되면 처리할 수 없다.
- 그래서 존재하는 것이 재귀 호출이다.

```python
// Python

def total(xs):
   result = 0
   for x in xs:
      if is_integer(x):
         result += x
		else:
         # x는 내포 리스트이기 때문에 total로 안에 든 값을 합산한다.
         result += total(x)
         
	return result
```

- 함수 total은 몇 중으로 된 내포 리스트가 전달되어도 안에 있는 모든 수를 합산할 수 있도록 되었다.

<br>

### 정리

- 프로그램의 규모가 커지면 전체적인 구조를 파악하기 어려워진다.
- 비슷한 처리를 몇 번이고 반복해서 쓰고 싶어지는 경우도 생긴다.
- 함수는 이 문제를 해결하기 위해 탄생했다.
- 한 그룹인 코드를 배내어 의미 있는 이름을 붙여서, 그 코드가 무엇을 하고 있는지 파악하기 쉬워진다.
- 그리고 그 함수를 다른 장소에서 호출하여 사용함으로 재사용도 가능해진다.
- 함수를 사용함으로 '재귀 호출'이라는 코딩 기술이 탄생했다.
- 재귀 호출은 내포 구조로 된 데이터를 다루기에 적합한 기법이다.

------

<br>

## 6장 에러 처리

<br>

### 프로그램도 실패를 한다

- 프로그램도 실패를 한다. 파일에 무엇을 기록하려고 할 때 하드 디스크가 이미 꽉 차 있는 경우 기록에 실패한다.
- 파일에 기록하려고 했는데 실패한 경우에 어떤 경고도 없다면 사용자는 실패를 알아차리기 힘들다.

<br>

### 실패를 어떻게 전달할까?

<br>

#### 반환값으로 실패를 전달한다

- 예를 들어 shippai 함수가 반환하는 값을 '성공했을 때 0을 반환, 실패했을 때 그 이외의 값을 반환한다'고 정해두는 방법이다.

```c
// C언어

if(shippai()){
   /* 에러 처리 */
}
```

<br>

### 어떤 경우에 예외를 던질까?

<br>

#### 함수 호출 시 인수가 부족한 경우

- 예를 들어 인수 두 개를 가진 함수가 인수 한 개만 호출한 경우 어떤 일이 벌어질까?
- Python과 Ruby는 함수 호출 시점에서 예외를 던진다. 그러나 JavaScript는 인수에 '미정의를 의미하는 특수한 값(undefined)'을 사용해서 처리를 계속한다.

```python
// Python

def foo(x, y):
   print x, y
   
foo(1)
```

```ruby
// Ruby

def foo(x, y)
   p x, y
end

foo 1
```

```javascript
function foo(x, y) {
   console.log(x, y);
}

foo(1)
```

<br>

#### 틀리면 바로 예외를 던진다

- 프로그래머도 사람인 이상, 실수를 피할 수는 없다.
- 코드의 품질을 높이기 위해서는 버그가 존재하는 것을 빨리 알아채고 수정하는 수밖에 없다.
- 예외의 이점은 '실패를 놓치지 않는 것'이다.
- '이상하면 처리를 정지하고 빨리 보고해야 한다'는 설계 이념을 'fail first'라고 한다.

<br>

### 정리

- 실패를 전달하는 방법은 크게 2가지로 나눌 수 있다.
  - 반환값으로 알린다
  - 실패하면 점프한다
- 어느 쪽에도 장단점이 있어서 각각의 장단점을 잘 파악한 후 적재적소에 사용하는 것이 중요하다.

<br>

## 7장 이름과 스코프

<br>

### 왜 이름이 필요할까?

- 변수나 함수의 이름은 50년 이상 전에 발명되었다.

<br>

#### 어떻게 이름을 붙일까?

- 어떻게 하면 '책꽂이의 좌측 끝에서 36번째 책을 꺼내'라고 말하는 대신, '영어 사전을 꺼내'라고 말할 수 있게 될까?
- 컴퓨터가 이름과 물건을 대응시키는 표를 가지고 있으면 된다.

<br>

### 스코프의 진화

- 스코프(scope)란 이름의 유효 범위다.

<br>

### 정리

- 이름의 유효 범위는 정적 스코프가 주로 사용되고 있다.

<br>

## 8장 형

<br>

### 형(型)이란?

- 








<br>

> 칼럼 이해력을 확인하기 위해서는 결과물(Output)을 확인한다
>
> 이해한 것이 맞는지를 확인하기 위해서는 결과물(Output)이 필요하다.
>
> 프로그래머는 이런 점에서는 혜택을 받고 있다.
>
> 프로그래밍 언어의 결과물은 언어 처리계가 틀린 곳을 자세히 지적해준다.
>
> 에러 메시지를 이해하려 하지 않고서는 언어 처리계와 제대로된 커뮤니케이션을 할 수가 없다.

<br>

> 칼럼 무엇을 배우면 좋을지 모르는 이유
>
> '무엇을 배우면 좋을까?'라는 질문에 대답하기 전에 한 가지 물어보고 싶다.
>
> '무엇을 만들고 싶은가?'
>
> 목적이 명확하지 않으면 최선의 방법 또한 가르쳐줄 수 없다.
>
> '무엇을 배울지, 무엇을 배우면 좋을지'를 정할 때 필연적으로 지표가 될 수 있는 것이
>
> '무엇을 만들고 싶은가?', 즉 목적을 명확히 하는 것이다.
>
> 그리고 목적을 달성하기 위해 필요한 것부터 배우면 된다.
>
> '무엇을 만들까?'를 결정할 수 없다면, 처음부터 완벽한 것을 만들려고 하는 것은 아닌지 고민해보자.
>
> 처음부터 굉장한 것을 만들려고 생각해서 오히려 손도 대지 못하고 있다면,
>
> 시간이 흘러도 굉장한 것을 만들 수 없다.
>
> 이 과정을 반복해가면 보다 복잡한 것을 만드는 능력이 몸에 베게 된다.

<br>

> 칼럼 이름
>
> 함수를 사용한 처리에 이름을 붙이는 행위는
>
> '처리가 시작되는 메모리상의 위치'를 수치로 표현하는 대신,
>
> 알기 쉬운 문자열로 표현하는 행위이다.

<br>

> 칼럼 이빨로 씹다
>
> 큰 고기를 한 입에 먹을 수는 없다.
>
> 우선은 입에 넣을 수 있는 크기로 잘라서, 이빨로 씹은 후 삼켜야 한다.
>
> '이해'란 것도 같다.
>
> 저자도 방대한 정보를 앞에 두고 좌절한 것이 한두 번이 아니다.
>
> 그럴 때 사용할 수 있는 3가지 전략이 있다.
>
> '필요한 부분부터 흡수한다',
>
> '대략적인 부분을 잡아서 조금씩 상세화한다',
>
> '끝에서부터 차례대로 베껴간다'이다.

<br>

