---
layout: post
title: "대살개문"
categories: dev
tags: books
---

## 대한민국을 살리는 개발자 문화

###### 임백준 저

<br>

#### 지은이의 말

- Learn(배우고), Enjoy(즐기고), Solve(해결하고), Share(공유하라). 이렇게 네 가지 속성을 모으면 그게 개발자 문화다.

<br>

## 1부 현실 - 야근은 미친 짓이다

- 프로그래머가 정신을 집중해서 양질의 코드를 만들어낼 수 있는 시간의 최대치는 하루에 2~3시간이라는 것이 정설이다.
- 프로그래밍은 '양'의 노동이 아니라, '질'의 노동이다. 손가라기 아니라 머리로 하는 일이다.
- 프로그래밍 할 때 프로그래머의 두뇌는 CPU 레지스터와 메모리의 확장된 버전이 된다. 수많은 변수의 상태와 상호작용이 두뇌에 기억되고, 각종 클래스와 패키지 이름, 구현해야 하는 알고리즘의 개요, 다른 하위 시스템과의 상호작용, 방금 수정한 버그의 내용, 사용자 요구 사항 등이 모두 기억된다. 1차원적인 기억의 문제가 아니다. 기억한 내용이 서로 다차원적인 방식으로 상호작용하는 것을 실시간으로 파악하고 판단해야 한다. 엉망으로 꼬이고 엉킨 실타래의 끝을 놓치지 않고 추적하는 것이다.
- 에너지가 고갈된 상태에서 정상적인 코드를 만들기는 불가능하다.
- 프로그래머라면 하루에 2시간 이상 코드를 생산할 수 없다고 해서 조금도 자책하지 않기 바란다.

<br>

### 불안은 S/W 프로젝트를 잠식한다

- 시스템의 전체적인 그림을 크게 그려놓고 그에 수반되는 사항을 일목요연하게 정리한 아키텍처도 부재했다. 최종 제품을 얼마나 많은 사용자가 사용할 것인지, 얼마나 많은 데이터가 발생하는지, 반응 속도가 어느 정도로 빨라야 하는지, 보안 수준은 어느 정도로 구현해야 하는지, 하드웨어 장비는 무엇을 쓸 것인지, 통신 프로토콜은 어떤 것으로 할 것인지, 플랫폼과 언어는 어떤 것으로 정할 것인지 등등.
- 불안에 휩싸여 있는 사람들에게 딱히 해줄 말도 없다. 다만 그들이 두려워해야 하는 것은, 사소한 '손해'나 알량한 '이익'이 아니라, 프로젝트의 총체적인 실패를 의미하는 '허접한 결과물'이라는 점을 지적하고 싶다.

<br>

### 우리나라 개발자들의 경쟁력과 실패할 권리

- 우리나라 개발자들이 잠재력을 발휘하지 못하는 이유를 나는 '실패할 권리'가 없는 사회 환경에서 찾는다. 아이디어를 가진 사람이 두려움 없이 도전할 수 있는 조건이 부재한 것이다.
- 성공이라는 꽃은 수없이 반복되고 누적되는 실패라는 거름을 먹고 자란다. '실패할 권리'가 없는 곳에는 성공도 없다.
- 프로그래머가 소프트웨어 개발과 관련된 일체의 의사결정 과정에서 주체가 되어야 한다. 소프트웨어의 속성을 이해하지 못하는 사람이 개발자를 종처럼 부리는 기이한 현상은 중단되어야 한다.
- 손에 비트와 바이트를 묻힌 채로는 일정한 수준 이상으로 진급할 수 없기 때문에, 스스로 코딩을 포기하는 사람도 있다.
- 실력이 좋은 프로그래머는 실력이 좋은 다른 프로그래머를 사랑한다. 함께 일하는 것이 즐겁기 때문이다.
- 자기 아이디어를 실현하려고 노력하다가 장렬히 실패한 과거를 대기업에 입사했던 기록보다 더 자랑스러워하는, 실패할 권리와 자유가 강처럼 넘쳐흐르는 사회를 꿈꾸어본다. 그런 문화가 형성되지 않는다면 '우리나라 개발자들의 수준'을 '세계 수준'에 비교하는 것은 의미가 없다.

<br>

### 나는 프로그래머다

- 대한민국의 소프트웨어 업계는 갈라파고스다. 재능과 열정이 있는 사람들이 모여들고, 이익을 좇는 자본이 분주하게 돌아다니고, 기상천외한 아이디어와 문화가 풍성하게 꽃을 피우는 해외 각국의 소프트웨어 업계의 현실과 괴리되어 있는 섬이다.

<br>

### 프로그래머에게 자격증은 모욕이다

- 자격증을 획득하는 것은 진짜 '실력'을 쌓는 일과 아무런 상관이 없을 뿐만 아니라, 심지어 진짜 실력을 쌓는 행위를 가로막고 억압하는 장치에 불과하다.
- 진짜 실력은 자격증을 따기 위해서 '공부'할 때 쌓이는 것이 아니라, 일과 놀이가 구분되지 않는 상태에서 프로그래밍에 몰입할 때 생긴다.
- 자격증을 따기 위한 공부에도 순기능은 존재한다. 몰랐던 사실을 알게 될 수도 있고, 제한적이긴 하지만 디버깅 방법이나 프로그램 설계 기술을 익힐 수도 있다. 그렇지만 그런 단편적인 지식은 실력을 구성하는 요소에서 작은 부분에 불과하다.
- 프로그래밍을 체계적으로 배우지 않고, 학원에서 속성으로 학습한 사람들은 자신의 약점을 내면화한다.
- 실력이 있으면 누구나 개발자가 될 수 있다. 다만 원하는 직장을 얻으려면 자신의 능력을 자격증을 통해서가 아니라 실제로 문제를 해결하는 능력을 통해서 보여줄 수 있어야 한다.

<br>

### 마이너리그에 속한 개발자를 위하여

- 고담 시티에 사는 개발자들은 이렇게 멋진 컨퍼런스에 참석할 여유가 없을 거라는 사실을 깨닫는 데는 오랜 시간이 필요하지 않았다.
- 한국의 개발자 세계는 메이저리그와 마이너리그로 엄격하게 분리되어 있다. 삼성, LG 같은 대기업, 카카오, 쿠팡 같은 잘 나가는 벤처기업 등 소수의 회사가 메이저리그를 형성한다. 개발자들의 수준도 높고, 연봉도 괜찮고, 하는 일도 재밌다. 이러한 회사들은 속속 판교로 모여들고 있다고 한다.
- 실력에 자신이 있는 사람은 마이너리그를 떠나서 프리랜서가 되고, 운이 좋으면 메이저리그에 입성하기도 한다. 하지만 소수다.
- 문화는 상호작용의 결실이다. 풍성한 하위문화가 넘쳐흐르지 않으면, 엘리트 문화도 꽃을 피우지 못한다.

<br>

### 삼성 소프트웨어 직군 테스트

- 회사의 목적은 효율성을 통한 이익의 극대화이기 때문에, 자기 적성에 맞지 않는 일을 하는 사람들을 찾아서 다른 부서에 배치하는 것이 당연하다는 논리다.
- 회사의 목적은 민주주의와 복지가 아니라, 이익창출이다.
- 누군가에게는 며칠 밤을 새울 정도로 재밌고, 평생을 바쳐도 아깝지 않은 열정의 대상인 프로그래밍을, 한순가의 코딩 테스트로 전락시킨 사건이다.
- 축구 감독은 선수들이 '시험'을 치르게 만드는 것이 아니라, 감독 스스로 선수를 알아볼 수 있는 안목을 기르기 위해서 노력한다. 그게 감독의 일이다. 진짜 선수는 특정한 테스트를 의식하지 않고, 진짜 감독은 테스트를 필요로 하지 않는다.
- 삼성은 자기가 감당해야 하는 몫을 직원들에게 전가했다는 점에서 비판을 받아야 한다. 80%가 합격할 정도로 '쉬운' 시험이었다지만, 본질은 선착순처럼 잔인하다.

<br>

### 소프트웨어 개발자는 전기 양의 꿈을 꾸는가

- 컨디션이 좋은 날은 머릿속에 펼쳐지는 코드의 추상 수준이 끈 풀린 풍선처럼 하늘로 올라간다. 깔끔하고 명쾌하게 연결되는 코드가 쏟아진다.

<br>

### 개발자에게 부탁하라

- 자본주의 사회에서 트래픽은 광고와 직결된다. 풍부한 트래픽은 높은 광고 수익을 의미하고, 빈곤한 트래픽은 낮은 광고 수입을 의미한다.
- 인터넷, 디지털, 모바일, 소프트웨어 시대에서 주인공은 개발자다.
- 기술 수준이 높은 개발자를 고용해서 팀을 구축하고, 그들이 회사 내부에서 마음껏 일을 저지르도록 장려해야 한다.
- 트래픽에 연연하는 것을 속물이라고 비난해서는 곤란하다. 모든 일은 사람이 모인 곳에서 시작되기 때문이다.

<br>

### 조인트 맞는 개발자

- 개발자를 개발자답게 대접하지 않으면, '갑'도 소프트웨어 답지 않은 소프트웨어를 손에 넣을 수밖에 없다.
- 개발자가 즐겁지 않은 사회의 미래는 없다.

<br>

## 2부 - 문화 - 만나고, 마시고, 토론하라

- 반응형(reactive) 시스템이란 응답속도(responsiveness), 확장성(scalability), 이벤트 주도(event-driven), 그리고 유연성(resilient)이라는 네 가지 개념을 하나로 아우르는 새로운 패러다임이다.
- 소프트웨어를 개발하는 업무에 종사하다 보면 여러 가지 희열을 맛보게 된다. 좋은 사람들을 만나서 서로의 관심사를 나누는 것은 그중에서도 으뜸이다.
- 매일 똑같은 책상에 앉아서 똑같은 생각만 하는 사람은 실력이 늘기 어렵다. 실력도 실력이지만 프로그래밍이 무척 재미있는 일이라는 사실을 느끼지 못하게 된다.
- 친구들을 만나고, 마시고, 토론하라. 그런 만남과 토론 자체가 프로그래밍이라는 행위의 일부이다.

<br>

### 오픈 소스를 넘어서. 개발자의 재능 기부

- 컴퓨터 프로그래밍 세계에서는 오픈 소스 프로젝트에 참여해서 누구나 무료로 사용할 수 있는 소프트웨어를 제작하는 것이 말하자면 일종의 봉사에 해당한다. 오픈 소스는 재능을 기부하는 것이고, 지식을 나누는 행위다.
- 오픈 소스는 프로그래밍을 진심으로 사랑하는 해커들이 자기들끼리 모여서 여는 축제라는 성격이 강하다. 사회가 필요로 하는 소프트웨어를 만드는 것이 아니라, 해커들이 필요로 하는 도구를 만드는 경우가 대부분이다.

<br>

### 5000억 원짜리 버그

- 버그는 프로그래머의 숙명이다. 김밥을 마는 손에 밥풀이 묻는 것처럼, 비트와 바이트를 만지는 손에는 버그가 달라붙는다.
- 불완전함은 인간이 가진 자연스러운 속성의 하나이기에, 키보드를 두드리는 사람의 손끝에서 버그가 쏟아져 나오는 것은 자연스러운 일이며, 현대 프로그래밍 방법론의 한계이다. 그래서 버그가 있느냐 없느냐는 논의의 대상이 될 수 없다. 그것이 얼마나 자주 발생하는지, 그것으로 인한 피해가 어느 정도인지를 문제로 삼을 수 있을 뿐이다.
- 버그는 자신을 탄생시킨 사람을 충격과 공포의 도가니로 몰아 넣는 잔인하고 배은망덕한 존재지만, 동시에 사람을 단단하고 강하게 만드는 채찍의 역할도 담당한다.
- 몇 가지 기술적인 교훈이 있다. 우선 사용되지 않는 낡은 코드를 반드시 삭제해서 없애야 한다는 점이다. 실행 파일만이 아니라, 소스 코드에도 적용되는 이야기다. 어떤 프로그래머들은 삭제해서 없애야 하는 이전의 논리를 주석 처리를 해서 남겨놓거나, 심지어 if 구문을 통해서 우회한다. 상당히 나쁘고 위험한 습관이다.
- 문서, 절차, 검토, 확인, 테스트와 같은 부가적인 행위들이 때로는 불필요한 요식행위처럼 느껴지기도 하지만, 때로는 불완전한 존재인 우리에게 도움을 주기도 한다는 점을 기억하자.
- 우리가 오늘 작성한 코드 안에도 버그는 살아서 숨 쉬고 있다.

<br>

### 정치보다 강한 소프트웨어의 힘

- 변하지 않는 요구 사항은 세상에 존재하지 않는 법이기 때문에 문제가 될 수 없다. 변하는 요구 사항을 제대로 수용하지 못하는 프로젝트가 있다면, 문제는 그 프로젝트이다.
- 프로젝트의 성공이 의미하는 바가 불명확하다면, 그것은 수사학에 불과하다. 많은 사용자가 동시에 웹 사이트에 들어와서 회원가입을 하고 무언가 선택할 수 있으면 프로젝트는 성공이고, 그렇지 않으면 실패다.
- 테스트라는 것은 나중에 몰아서 한꺼번에 수행하는 것이 아니라, 설계와 구현 자체와 뗄 수 없는 방식으로 결합되어 있는 '개발 과정'의 핵심적인 일부이다.
- 많은 방문자를 상정한 웹 사이트는, 기본적이고 핵심적인 기능을 갖춘 상태에서 베타 버전을 오픈해서 사용자들이 실제로 사용을 하도록 만드는 과정을 밟아야 한다.

<br>

### 창업국가의 비밀

- 컴퓨터 프로그래밍이라는 고도의 지적 노동은 일체의 정신적 억압으로부터 자유로운 당돌함과 자유를 바탕으로 한다.
- 지금 우리에게 필요한 것은 상식의 회복이다. 공동체에 대한 믿음이다.

<br>

### 신은 디테일 속에 존재한다

- 스티브 잡스나 알렉스 퍼거슨 같은 당대의 일인자들은 타인의 시선을 떠나서 스스로의 완벽함을 추구하기 위해 디테일에 집착했다.
- 누가 보고 안 보고는 정성을 들이는 이유와 아무런 상관이 없다.
- 디테일이 살아 있고, 빠르고, 안정감 있게 동작하는 코드를 작성하는 것은 `능력`의 문제인 경우가 많지만, 때로는 `태도`의 문제이기도 하다.
- 완성의 기준은 타인의 시선이 아니라, 자신의 내면에서 울리는 목소리가 되어야 한다.

<br>

### 어떻게 프로그래밍을 배울 것인가

- 프로그래밍은 이렇게 배우는 것이다. 노는 거다. 공부가 아니다. 경쟁이나 성적이라는 굴레로 가둘 수 없다.

<br>

### 구글에 취직하는 방법

- 구글이 직원을 채용할 때 주목하는 부분은 무엇일까? 숫자로 표현되는 외형적인 '스펙'이 아니라, 소프트 기술(soft skill)이라고 불리는 자질이다. 프로그래머의 실력을 파악하기 위해서 코딩 실력을 확인하는 것은 물론이지만, 그밖에 리더십, 지적 겸손(intellectual humility), 협동(collaboration), 적응력(adaptibility)과 같은 자질을 중시한다. 이런 자질은 학교 성적이나 브랜드와 직접적인 함수 관계가 없다.
- 가장 중요한 자질은 지적 겸손이다. 타인의 아이디어를 인정할 수 있는 능력이고, 실수로부터 배우는 능력이다.
- 구글은 특정한 기술을 깊게 아는 것을 뜻하는 '전문성(expertise)'에 낮은 비중을 둔다. 전문성보다는 부족한 정보를 토대로 최선의 판단을 내리는 적응력이 중요하다. 새로운 지식을 빨리 흡수해서 자기 것으로 만드는 능력이 더 중요하다. 지식이 아니라 메타 지식이다.
- 프로그래머가 다루어야 하는 정보의 양이 과거에 비해서 비교할 수 없을 정도로 많고, 의미 있는 소프트웨어를 개인이 만드는 것이 아니라 팀이 공동으로 작업해야 하는 요즘에는 새로운 것을 빨리 습득할 수 있는 능력을 갖춘 프로그래머가 요구된다.
- 타인의 아이디어가 자기 생각보다 낫다고 판단되면 즉각적으로 수용할 수 있는 능력이 있어야 하고, 실수를 부끄러워하는 것이 아니라, 실수로부터 배우기를 즐기는 사람이어야 한다.
- 어떤 언어를 얼마나 알고 있는가 하는 것보다, 어떤 언어를 얼마나 빨리 배울 수 있는가 하는 것이 더 중요한 시대가 되고 있다.
- 지식보다 메타 지식이 중요해지는 시대의 흐름을 정확하게 읽고 있는 것이다.

<br>

### 우리도 가상 모임을 시작하자

- 중요한 것은 문화다. 문화는 흙이고, 기술은 꽃이다. 기술은 문화라는 흙을 먹고 자라는 꽃이다.

<br>

### 늙은 개발자의 노래

- 프로그래밍에 젊음과 열정을 바친 사람들은 40세 생일을 맞이한 이후에 모두 어디로 가서 무엇을 하는 것일까?
- 늙은 개발자의 노래 소리가 들리게 만들어라. 노래 소리가 충분히 크게 들리면, 아이들은 자연스럽게 SW에 관심을 갖고 모여들 것이다. 나이 든 개발자들은 노래를 부르면서 어린 아이들에게 코딩을 가르치고, 젊은 개발자들에게 지혜를 나누어줄 것이다. 진짜 SW 교육은 그런 것이어야 한다.

<br>

### 페이스북의 다운과 자동화의 덫

- 컴퓨터 시스템은 데이터베이스에 저장되어 있는 데이터를 메모리에 올려놓고 사용하는 경우가 많다. 로그인 요청과 같은 사용자 질의가 들어오면 멀리 있는 데이터베이스에 갈 필요 없이 메모리에 있는 데이터를 읽고 서비스를 제공하면 처리 속도가 빨라지기 때문이다. 이때 메모리에 저장된 데이터를 `캐시`라고 부른다. 캐시는 임시적인 값이기 때문에 데이터베이스에 있는 값이 변경되면 새로 갱신을 해주어야 한다.
- 시스템의 안정성을 뽐내던 페이스북이 다운되었다는 소식은 순식간에 온라인을 뜨겁게 달구었다. 페이스북은 이미 단순한 소셜 네트워킹 서비스가 아니라, 실제 서비스를 제공하는 플랫폼으로 자리를 잡은 상태이기 때문에 긴 장애시간은 온라인과 오프라인을 아우르는 일대 사건이었다. 문제의 원인은 비교적 간단했다. 페이스북은 캐시의 값을 갱신해주는 작업을 자동화했다. 캐시의 값이 정상적인지 여부를 판단하고, 정상적인 값이 아니면 데이터베이스에서 새로운 값을 읽어서 캐시의 값을 갱신하는 코드를 작성한 것이다. 그런데 사소한 실수로 인해서 그 값에 오류가 있었다. 데이터베이스에 있는 값이 캐시에 저장되자마자 자동화된 캐시 갱신 코드가 동작을 개시했다. 코드는 캐시 값이 정상적이지 않다고 판단하여 그 값을 데이터베이스에서 읽어들이는 작업을 수행했다. 하지만 이 작업이 엄청나게 많은 사용자를 대상으로 동시에 이루어졌기 때문에 데이터베이스는 초당 수십 만에 달하는 질의를 받고 마비되었다. 새로운 값을 읽었다고 해도, 데이터베이스에 저장되어 있는 값 자체가 오류를 담고 있었기 때문에 캐시를 갱신하는 작업은 무한히 반복되었다. 페이스북 기술자들은 무한히 반복되는 코드를 멈추려고 애썼지만, 그렇게 할 수 없었다. 유일한 방법은 시스템 전체를 멈추고, 자동화된 캐시 갱신 코드를 제거하고, 시스템을 다시 시작하는 방법밖에 없었다. 소프트웨어 개발자라면 알겠지만, 가장 치욕적인 해결 방법이다. 그 작업을 수행하는 데 걸린 시간이 2시간 30분이었다.

<br>

## 3부 기술 - 저물어가는 프로그래밍의 시대

- 우리가 방문하는 웹 사이트의 대부분은 사람이 아니라 기계가 만든 장소로 변하게 될 것이다.

<br>

###### 함수형 프로그래밍이라는 유령

- 함수형 패러다임을 구성하는 개념들은 실제로 상당히 추상적인 수학적 개념을 바탕으로 한다.

<br>

### 함수형 프로그래밍을 통한 간결한 코딩

- "함수형 프로그래밍은 모듈의 경계를 어디쯤으로 정해야 하는지, 모듈의 재사용성을 어떻게 향상시킬 수 있는지 등에 대해서 전과 다른 방식으로 사고하게 만들었다. 엄청난 분량의 데이터를 다루고, 빠르게 변하는 요구 사항에 대응하고, 급박한 일정 속에서 일해야 하는 현대 프로그래밍 고유의 문제들을 해결하는 데 있어서 함수형 프로그래밍이 매우 유용하다는 결론을 내리게 되었다." <자바 개발자를 위한 함수형 프로그래밍>, 딘 왐플러
- 왐플러가 전달하고자 하는 메시지의 핵심은 특정 언어와 관련된 것이 아니라, 함수형 프로그래밍이라는 패러다임 일반과 관련이 있다. 예컨대 자바나 C#처럼 함수형 언어가 아닌 명령형 언어를 사용한다고 해도 프로그래머가 이미 함수형 프로그래밍의 세례를 받고 난 이후라면 함수형 프로그래밍을 몰랐던 과거에 비해서 비교할 수 없을 정도로 '간결한' 코드를 작성할 수 있다는 말이다.
- 자바에서 Map이나 HashMap으로 표현하는 데이터구조가 C#에서는 Dictionary라는 이름으로 불린다.

<br>

### NoSQL의 기원

- 붕어빵에 붕어가 없듯이, NoSQL은 SQL에 대한 것이 아니다. NoSQL은 관계형이라는 패러다임을 극복하기 위한 노력, 클라우드 컴퓨팅으로 대표되는 클러스터 환경에 맞는 데이터베이스를 만들려는 노력, 엄청난 분량과 속도로 생산되는 빅데이터를 처리하기 위한 노력, 미리 정의된 스키마를 사용하지 않으면서 데이터를 처리하고자 하는 노력 등을 하나로 묶어서 지칭하는 포괄적인 표현이다.
- NoSQL 운동은 관계형 데이터베이스의 종말을 의미하는 것이 아니다. 대신 컴퓨팅 환경에 새로운 차원의 문제가 주어지면서, 관계형 패러다임으로 모든 문제를 해결할 수 있는 시대가 끝났음을 알리고 있을 뿐이다.

<br>

### 액터 모델과 아카

- 멀티스레드 코딩은 프로그래머의 숙명이다.
- 아무리 실력이 뛰어난 프로그래머라고 해도 일일이 잠금장치(lock)를 이용해서 버그가 없는 멀티스레드 코드를 작성하는 것은 불가능하다. 불가능하다고 단언할 수 있는 이유는, 코드의 정확성을 수학적으로 증명할 수 없기 때문이다.
- 멀티스레드 코드는 작성하기도 어렵지만, 디버깅은 더 어렵다. 디버깅을 하기 위해서 개입을 하는 순간, 코드의 동작이 전과 달라지기 때문이다.
- 프로그래밍 세계에서는 디버깅하기 어려운 멀티스레드 관련 버그를 '하이젠버그(Heisenbug)'라고 부르기도 한다.
- 액터(actor)는 '스레드' 혹은 '객체'와 구별되는 추상이다. 액터가 차지하는 메모리 공간은 다른 스레드 혹은 액터가 접근할 수 없다. 다시 말해서 액터 내부에서 일어나는 일은 어느 누구와도 '공유'되지 않는다. '공유'라는 속성을 제거함으로써 멀티스레드와 관련된 문제의 대부분을 제거했다.

<br>

### 비트코인 채굴 방법

- 월스트리트는 모든 것을 거래한다. 주식, 채권, 금처럼 눈에 보이는 것만이 아니라, 날씨나 신용처럼 눈에 보이지 않는 것까지 거래한다. 이익을 남길 수 있다면 태양의 흑점까지 거래할 사람들이다. 이런 사람들의 눈에 비트코인처럼 떠들썩한 물건이 보이지 않을 리 없다.
- 펀드 매니저들이 비트코인을 거래한다는 것과, 그것이 화폐로서 인정을 받는다는 것은 별개의 문제다.
- 프로그래머라면 간단한 암호 원리와 '해시 함수'에 친숙하기 때문에 비트코인 채굴 과정이 구체적으로 어떤 작업으로 이루어져 있는지 이해하는 것이 어렵지 않다. 하지만 프로그래밍에 익숙하지 않은 사람에게는 이해할 수 있는 비유가 필요하다.
- 주머니 안에 1부터 1000까지 숫자가 적힌 공이 들어 있다. 눈을 감고 공 하나를 꺼내서 번호를 확인한다. 확인한 공은 다시 주머니에 넣고 흔들어서 섞는다. 이때 꺼낸 공에 적힌 숫자가 50보다 크면 같은 작업을 반복하고, 50보다 작으면 비트코인을 하나 획득하게 된다. 공을 꺼내고, 확인하고, 넣는 작업을 빠르게 반복하면 50보다 작은 수가 적힌 공을 꺼낼 가능성이, 즉 비트코인을 획득하게 될 가능성이 더 높아진다. 비트코인 채굴 ㄱ작업에 최적화된 하드웨어와 소프트웨어가 제작되는 이유다.
- 너무 많은 사람이 작업에 참여하거나, 성능이 좋은 하드웨어가 등장해서 비트코인이 당첨되는 속도가 빨라지면 '50보다 작은 수'라는 규칙에서 50을 20으로 낮추면 당첨자가 나오는 속도를 조절할 수 있다.
- 실제 비트코인 채굴 과정에서는 SHA-256이라는 해시 함수가 사용된다. 어떤 숫자나 텍스트를 입력하면 256비트로 이루어진 2진수 값을 출력하는 함수다. 비밀번호나 중요한 내용을 암호화하기 위해서 사용되는 함수로, 현존하는 방법 중에서 가장 강력한 것의 하나로 인정받고 있다. 이러한 해시 함수의 특징은 입력에서 출력으로 가는 과정은 순식간이지만, 출력된 내용으로부터 입력된 내용을 거꾸로 유추하는 것은 거의 불가능하다는 점이다. 그리고 동일한 입력에 대해서는 언제나 동일한 값을 출력한다.
- 채굴 작업을 시작하면, 비트코인 공식 사이트는 일정한 텍스트, 즉 SHA-256 해시 함수에 입력될 내용을 전달해준다. 그러면 채굴 작업을 수행하는 컴퓨터는 전달된 내용을 해시 함수에 넣고 실행한다. 이때 출력된 값이 공식적으로 정해져 있는 값보다 작으면 비트코인을 획득한 것이다. 채굴 작업을 수행하는 컴퓨터에서는 해시 함수를 실행하기 전에 공식 사이트에서 보내준 텍스트에 임의의 텍스트를 추가한다. 임의의 텍스트를 nonce라고 부른다.
- 결국 비트코인 채굴 작업은 임의의 텍스트, 즉 nonce의 값을 이리저리 바꾸어보녀서 정해진 값보다 작은 해시 값을 얻을 때까지 함수를 실행하는 과정을 의미한다. 이런 과정은 어려운 수학 문제를 풀기 위해서 공식이나 원리를 사용하는 것이 아니라, 1부터 1,000,000까지의 수를 일일이 대입해보는 것과 비슷하다. 무한히 반복되는 단순 노동의 끝판왕이다. 사용되는 전력과 컴퓨팅 파워를 고려해보면, 인류에게 그다지 유용한 일을 수행하는 것은 아니다.

<br>

### 핀테크, 돈의 흐름을 바꾸다

- 화폐의 본질은 정보다. 정보는 네트워크를 통해서 흐른다. 미래의 금융 서비스는 네트워크를 장악하는 회사의 손에 달려 있다.

<br>

### 머신러닝의 시대

- 우리말로 기계학습이라고 부르는 머신러닝은 통계학과 컴퓨터 프로그래밍이라는 두 개의 산줄기가 만나서 형성한 산맥이다. 핵심은 미래에 대한 예측이다. 곳곳에 존재하는 컴퓨터, 휴대폰, 센서, CCTV, 단말기 등이 뿜어내는 엄청난 양의 데이터를 분석해서 일정한 패턴을 찾아내는 통계의 마술이다.
- 아마존 홈페이지를 방문하면, 머신러닝 알고리즘은 나와 비슷한 통계적 속성을 가진 사람들이 구매한 책을 찾아내서 내 화면에 보여준다. 축적된 데이터를 이용해서 미래의 내가 어떤 책에 관심을 가질 지 예측하는 것이다.

<br>

## 문제는 알고리즘이다

- 알고리즘의 정의

> "A set of steps that are followed in order to solve a mathematical problem or to complete a computer process."
>
> "수학적인 문제를 해결하거나 컴퓨터 프로세스를 완결하기 위해서 차례로 뒤따르는 단계의 집합."

<br>

- 알고리즘은 어떤 문제를 해결하기 위해서 필요한 규칙을 이해하고, 그러한 규칙을 단계별로 적용해서 문제를 해결하는 것을 의미한다.
- '규칙을 이해하고, 그런 규칙을 적용해서 문제를 해결하는 것'이 바로 프로그래밍이다.
- 대학에서 학생들이 배워야 하는 것은 특정한 API를 다루는 '코딩' 능력이 아니라, 주어진 문제를 해결하기 위해서 규칙을 이해하고, 규칙을 단계별로 적용해서 문제를 해결하는 능력이다. 즉, 코딩이 아니라 알고리즘이다. 코딩은 알고리즘이라는 능력이 겉으로 드러나는 여러 가지 방식의 하나일 뿐이다. 코딩은 외공이고, 알고리즘은 내공이다.
- 요즘처럼 기술 변화의 속도가 빠른 시대에는 특정 기술, 플랫폼, 언어, API에 종속되는 코딩 기술의 가치가 전보다 크지 않다. 오히려 낡은 기술을 버리고 새로운 기술을 재빨리 익히는 능력이 중요하다.
- 알고리즘은 방향 전환을 가능하게 만들어주는 일종의 '메타 능력'이다.
- 프로그래밍이라는 기술은 알고리즘이라는 세포로 이루어져 있다. 알고리즘이라는 세포의 내부에 존재하는 DNA는 논리다. 만사에 논리적인 사람은 좋은 코드를 작성한다.
- 알고리즘이 얼마나 중요한가 하면, 프로그래밍 그 자체라고 말할 수 있을 정도로 중요하다. 문제는 알고리즘이다.

<br>

### 이세돌과 알파고

- 알파고의 내면은 인간의 흉내를 낸 신경망 알고리즘으로 이루어져 있다. 엄청난 규모의 데이터가 몇 개의 단계로 구분되어 있는 알고리즘을 거치면서 필요한 답으로 수렴된다. 시행착오와 실수를 겪으면서 스스로의 사고능력을 발전시킨다는 점에 있어서 인간과 닮았다.
- 인공지능을 연구하는 사람들은 알파고를 만들었지만, 그것이 어떤 원리에 의해서, 왜 그렇게 동작하는지 명쾌하게 설명하지 못하고 있다. 딥러닝 패턴을 인식하거나, 대규모 연산이 하나의 답으로 수렴하는 과정을 수학적으로 설명하지 못하는 것이다.

<br>

### 인공지능, 문제는 바둑이 아니다

- 알파고가 놀라운 점은 바둑 실력이 아니라 스스로 보고 배우는 능력이다. 무엇을 배울지 결정하는 것은 사람이지만, 얼마나 빠른 속도로 어디까지 배울지 정하는 것은 알파고 자신이다.

<br>

### 인공지능 시대의 도래

- 인공지능은 바다다. 이 거대한 바다 앞에서 리눅스와 윈도우의 구분 같은 것은 개울물에 불과하다. 자기가 선호하는 회사, 생태계, 테크놀로지 스택에 사로잡힌 채 집착하는 사람은 자기 미래를 제한하는 치명적인 실수를 저지르고 있는 것이다.

<br>

## 4부 개발자 - 멘토는 없다

- 멘토와 멘티라는 관계가 발설되는 순간, 두 사람 사이에는 암묵적인 권력 관계가 성립한다. 그런 권력 관계는 '물질적 이득'을 토대로 구축된다. 멘티 역시 멘토와의 관계 속에서 이득을 추구한다. '배움'이라는 완곡한 표현으로 포장되긴 하지만 권력 관계에 자발적으로 발을 들여놓는 멘티의 속마음도 이익을 얻는 데 집중된다. 멘토에 대한 인간적인 존경과 애정이 아니라 '그가 나에게 무엇을 줄 수 있는가'가 관심사다.
- 프로그래머들은 자기가 속한 팀에서 자기가 가장 실력이 낮은 사람이 되도록 애쓰라는 격언이 있다. 배울 사람이 없는 팀에서 오래 머물지 말라는 뜻이다.
- **프로그래밍은 책이나 수업보다 다른 사람의 작업을 어깨 너머로 보면서 배우는 것이 왕도**이기 때문에, 개발자들은 배우고 가르치는 관계에 갈증을 느낀다.
- 멘토는 없다. 스스로 마음을 일으키는 발심(發心)이 핵심이다. 발심을 개발자 용어로 달리 표현하면 '코딩신을 영접'하는 것이다.
- 굳이 누가 가르쳐주고, 누가 배우는지 구별할 필요가 없다. 가르치는 사람이 더 많이 배우기도 하고, 배우는 사람이 가르침을 주기도 한다.
- 코딩신을 영접한 사람의 눈에는 자신에게 가르침을 주는 친구가 사방에 출몰한다. 코딩신을 영접한 사람은 코딩신을 영접한 사람을 알아본다.
- 갈림길을 만나면 머리가 계산을 하기 전에 심장이 저절로 움직이기 때문에 다른 사람에게 물어볼 필요가 없다. 이미 행복하기 때문에 전망에 연연하지 않으며, 전망이 없으면 전망을 만들고, 길이 없으면 길을 만들겠다는 배짱과 낙관이 충만하다.
- 공부(工夫)에서 '공'은 하늘과 땅을 잇는 것을 표상한다. 그렇게 엄청난 일을 스스로 하지 않으면 누가 대신 해줄 수 있을까?
- 멘토에게 기대는 것은 자신을 속이는 일이다.

<br>

### 소프트웨어 개발자와 영어

- "내가 아는 언어의 한계가 곧 내가 사는 세상의 한계다." -비트겐슈타인
- 영어가 별다른 장애가 아닌 사람과, 영어 때문에 훌륭한 자료를 마음껏 활용하지 못하는 사람이 갖는 차이는 생각보다 크다.
- 인터넷에 무료로 존재하는 값진 자료들을 마음껏 활용할 수 있을 정도로 언어 능력의 지평을 넓혀야 한다. 그것은 선택이 아니라 필수다. 좋은 개발자가 되기 위한 최소한의 필요조건이다.

<br>

### 개발자의 불안, 당신만 그런 것은 아니다

- 프로그래밍이란 '일'은 대단히 재미있지만, 동시에 강력한 스트레스를 자아내는 활동이다.

<br>

### 기술적 빚과 프로그래머의 실력

- 엔지니어가 시간의 압박 속에서 타협했을 때, 즉 하드코딩과 같은 험한 지름길을 택하면서 정상적인 경로에서 이탈했을 때 그 엔지니어는 미래의 엔지니어에게 부채를 안기는 것이다. 와드 커닝햄은 이러한 부채를 `기술적 빚(technical debt)`이라는 적확한 표현에 담아낸 바 있다.
- 하드코딩과 같은 기술적 빚이 나쁜 이유는, 하드코딩은 필연적으로 다른 하드코딩을 부르고, 버그도 부르고, 체계적인 테스트 과정을 방해하며, 무엇보다도 하드코딩을 바로잡을 수 있는 시간이 결코 오지 않기 때문이다.
- 프로그래밍 세계에서는 일단 빚을 지면 그걸로 끝이다. 원금을 갚을 수 있는 날은 결코 오지 않는다.
- 기획자는 요구 사항을 정확하게 포착하고, 그것이 어느 정도의 우선순위를 갖는지 설명하고, 얼마나 촉박하게 요구되고 있는지에 대해서 최선을 다해서 설명을 하면 된다. 나머지는 프로그래머의 판단에 맡겨야 한다. 그렇게 하는 것이 진정한 의사소통이다.
- 프로그래머는 주어진 정보를 토대로 최선의 작업 방법을 구상하고, 작업을 수행해야 한다. 코드 상태, 요구된 내용의 복잡성, 자신의 실력, 다른 일들과의 우선순위 등을 충분히 고려해서 가장 빠르게 작업할 수 있는 시간을 기획자에게 알려주어야 한다.
- 허황되지도 않고, 너무 낙관적이지도 않게 현실적인 수준으로 시간을 예측하는 것은 실력이 뛰어난 프로그래머가 반드시 갖추어야 하는 실력의 일부다.

<br>

### 그대가 엉터리 개발자라는 신호들

1) 코드를 머리로 돌릴 수 있는 능력의 부재

- 코드를 머리로 돌리는 능력은 개발자에게 기본이다. 이러한 능력의 부재는 어떤 면에서 노력으로 해결할 수 있는 것이 아니다. 하루라도 빨리 다른 일을 시작하는 것이 더 나을 가능성이 크다.

<br>

2) 사용하는 언어의 프로그래밍 모델을 제대로 이해하지 못하는 것

- 끊임없는 학습과 자유분방한 창의력을 요구하는 프로그래밍이라는 행위를 기계적인 코딩, 단순히 반복되는 잡무, 혹은 하기 싫지만 어쩔 수 없이 하는 회사 일로 대하는 사람은 앞으로 20년 동안 경험을 쌓아도 기술적으로 변화가 있을 리 없다.

<br>

3) 학습 능력의 부재

- 많은 것을 알고 있는 것처럼 보이는 사람은 그만큼 열의를 갖고 학습을 하기 때문이다.
- 중요한 것은 공부를 통해서 습득한 지식의 분량이 아니다. 중요한 것은 공부를 하는 방법, 즉 메타 지식에 해당하는 학습 능력 자체다.
- 프로그래밍이라는 행위는 끝없는 학습으로 이루어져 있다.

<br>

4) 재귀 알고리즘을 이해하는 능력의 부재

- 이것은 머리로 코드를 돌리는 능력과 밀접한 관련이 있다. 재귀를 이용해서 정수의 팩토리얼 값을 구하는 정도는 대부분의 개발자가 어렵지 않게 이해한다. 피보나치수열까지도 괜찮다. 트리구조의 노드를 순차적으로 방문하는 알고리즘도 기본적인 것까지는 무리 없이 이해해야 한다. 하지만 하노이의 탑과 같은 알고리즘이 등장하면 숨이 막히기 시작한다.

<br>

6) 코드에 대한 불신

- 유닛테스트 코드를 작성하라고 시키면 실제로 검사되어야 하는 코드를 테스트하는 것이 아니라, 언어 자체의 문법이나 라이브러리 코드의 API를 확인하는 데 시간을 보낸다.

<br>

> 좋은 프로그래머가 되기 위해서 우리가 밟아온 과정, 혹은 앞으로 밟아야 하는 과정을 환기하여 다같이 행복한 프로그래밍을 하자.

<br>

### 그대의 힘으로 생각하라, 가차 없이 질문하라

- 인문학은 인간의 본성에 대해서 탐구하는 학문이다. 그래서 인문학의 본령은 모든 것에 대한 가차 없는 비관, 성역 없는 상상, 인간에 대한 애정, 그리고 실천에 놓여 있다. 자유를 추구한다는 점에서 인문학의 본질은 해커 정신에도 맞닿아 있다. 컴퓨터와 인터넷의 대중화에 앞장섰던 정의로운 해커들의 자유정신을 이야기하는 것이다.
- 인문학은 모든 것을 의심하는 데서 시작한다. 핵심은 질문을 멈추지 않는 데 있다. 눈앞에 보이는 것을 거꾸로 뒤집어 보고, 귀에 들리는 것을 반대로 생각해본다.
- 질문을 구성하는 힘은 인문정신의 핵심이다. 질문을 하기도 잘해야 하고, 받기도 잘 받아야 한다.
- 스스로의 힘으로 생각하고, 가차 없이 질문하라. 그것이 인문학이다.

<br>

### 프로그래밍을 공부하는 인문계 대학생들에게

1) 책임

- 바로 한국 IT 업계의 환경을 세계의 환경과 통합시키는 일이다. 인문계 대학생들은 상대적으로 사회 전체의 움직임을 관찰하고 그것을 말과 글로 설명하는 능력이 뛰어나다. 그런 사람들이 역할을 수행해주면 많은 도움이 될 것이다.

<br>

2) 문화

- 프로그래밍은 문화다. 기술은 문화라는 흙 위에서 피어오르는 꽃이다.
- 프로그래밍을 배울 때, 코드를 타이핑해서 컴파일하는 것에 급급하지 않아야 한다. 해당 기술이 탄생한 배경, 그것이 해결한 문제, 비슷한 기술 중에서 선택되지 못하고 도태한 기술, 그것을 처음으로 만든 사람의 삶, 그리고 그 기술을 뛰어넘기 위해서 사방에서 솟아오르고 있는 새로운 기술 등에 대해서 관심을 가져야 한다. 그런 관심이 모이면 문화가 된다.
- 진짜 개발자가 되려면 문화적 소양을 키우기 위한 노력이 필수적이다. 수없이 많은 컨퍼런스의 키노트 강연을 듣고, 인터넷 강의를 수강하고, 블로그에 글을 남기고, 책을 읽으며 안목을 넓혀야 한다. 개발자 모임에 참석하고, 배우고 싶은 개발자에게 과감하게 연락해서 사람을 알아가야 한다. 개발자 친구를 사귀어야 한다. 그렇게 문화적 소양을 키우면서 기술적인 내용을 함께 공부하는 것이다. 6개월이라는 시간이 중요한 것이 아니라, 어떻게 공부한 6개월인가가 중요하다.
- 초보자라고 해서 머뭇거리지 말아야 한다. 문화적으로 세련된 초보자는 편집기만 들여다보면서 10년을 보낸 개발자보다 섹시하다. 문화적 소양을 다른 말로 하면 '내공'이다.

<br>

3) 평생 공부

- 문화적 소양을 쌓기 위해서는 평생 공부가 필수다.
- 프로그래밍은 과학(science)과 공학(engineering)을 바탕으로 하지만, 기예(art)의 속성이 다분하기 때문에, 배운 시간이 아니라 재능에 따라서 더 많은 차이를 보인다. 그렇지만 재능과 상관없이 프로페셔널 개발자들은 매일 공부한다. 프로그래밍의 세계에는 그것으로 다 배운 거야라는 개념이 없다.
- 오리가 물에 뜨기 위해서 끊임없이 발을 움직이는 것처럼, 개발자는 개발자이기 위해서 매일 공부한다. 공부를 멈추는 순간, 더 이상 개발자가 아니다.
- 공부가 그 자체로 즐겁지 않거나, 마음이 조급한 사람은 프로페셔널 개발자가 되기 어렵다. 6개월 동안 배울 수 있는 것이 있다면 그것은 프로그래밍이 아니라 프로페셔널 개발자가 되는 방법일 것이다. 프로그래밍은 결코 6개월 만에 배울 수 있는 것이 아니다.

<br>

### 바보처럼 보이는 것을 두려워하지 말라

> 'Fake it till you make it.'
>
> '진짜가 될 때까지 진짜처럼 행동하라.'

<br>

- 거짓말을 하라는 이야기가 아니다. 실현 가능한 목표를 정하고, 목표가 이루어질 때까지 열정적으로 '행동'하라는 이야기다. 예컨대 PHP만 사용하던 개발자가 좋은 자바 개발자 자리를 만났을 때, 나는 자바를 모르니까, 하고 움츠러들지 말고 오래전부터 자바를 사용해온 사람인 것처럼 행동하고, 실제로 그런 사람이 되라는 이야기다. 생애 처음으로 강연 요청이 들어왔을 때, 내가 무슨 강연을, 하며 위축되지 말고 오래전부터 강연을 다닌 사람처럼 행동하고, 실제로 그런 사람이 되라는 이야기다.
- 저지르지 못하고 망설이고 고민하다가 아무것도 하지 못한다.

<br>

### '왜'에서 시작하라

- 개발자가 새로운 언어나 기술을 접할 때 취할 수 있는 전략은 크게 두 가지가 있다. 하나는 손에 흙과 피를 묻히면서 '어떻게'에 초집중하는 방법이다. 눈앞에 닥친 문제를 해결하는 테크닉에 초점을 맞추고, 배후에 존재하는 원리나 이론은 나중에 공부하거나 혹은 영원히 신경 쓰지 않는 전략이다. 또 하나의 방법은 선(禪)과 명상이다. 실제 명상을 이야기하는 것이 아니라, 그렇게 보일 정도로 키보드를 두드리는 일보다 원리와 개념을 이해하는 데 비중을 둔다는 뜻이다.
- '어떻게'가 아니라, `왜`와 `무엇`에 집중한다. 원리가 이해될 때까지 책을 읽고, 읽고, 또 읽는다.
- 대부분의 개발자는 첫 번째 방법을 선호한다. 시간이라는 측면에서는 더 효율적이기도 하다. 하지만 패러다임이 바뀌는 경우라면 사정이 다르다. 패러다임의 변화는 근본적인 원리와 이론에 대한 이해를 필수적으로 요구한다.
- 자바 개발자가 스칼라 개발자가 된다는 것은 단순히 사용하는 문법이 달라지는 것을 의미하지 않는다. 자바와 스칼라는 패러다임을 달리하기 때문에, 사고방식 자체의 변화를 수반한다.
- 반복되는 테크닉을 통해서 핵심적인 원리에 도달하는 능력을 가진 개발자도 많이 있다. 하지만 패러다임의 변화를 수용할 마음가짐이 있는 사람이라면 그런 욕망을 버려야 한다. 느긋한 태도로 원리와 이론에 집중해야 한다. '어떻게'는 생각하지 말고, '왜'와 '무엇'에 초점을 맞춰야 한다. 코드를 작성하지 못하더라도 그 안에 담긴 풍부한 추상의 정글에서 삼시세끼를 꼬박꼬박 다 해먹어야 한다.
- 고계 함수(higher-order function), 람다(lambda), 커링, 대수적(algebraic) 타입, 변경 불가능성, 참조 투명성(referential transparency), 타입클래스, 펑터(functor), 어플리커티브(applicative), 모노이드(monoid), 모나드, 범주 이론(category theory) 등으로 이어지는 끈끈한 추상의 늪을 통과한 다음, 중후한 내공을 실어서 코드를 작성해야 옳다.
- 이러한 추상은 '어떻게'의 잡다함을 눈앞에서 사라지게 만들기 때문에 자연스럽게 '왜'라는 질문과 연결된다. 그런 연결고리를 사색하는 태도가 선과 명상이다. 패러다임을 넘나드는 사람은 이런 태도가 필요하다.
- 우리 인생의 모든 것이 사실은 '어떻게'를 고민하는 것이 아니라, '왜'를 생각하는 데에서 출발할 때 해답을 얻게 되는 경우가 많다.
- 모든 것을 `왜`에서 시작하라.

<br>

### 개발자의 50가지 그림자

- 개발자의 다양성은 '분야'를 나눌 때보다 '실력'을 구분할 때 더 극적이다. 똑같이 '개발자'라는 직업을 가지고 있어도 코드를 만들어내는 능력에 믿기 어려운 차이가 존재하기 때문이다.
- 노력 자체를 즐기는 사람 앞에서는 타고난 재능이 무의미하다.

<br>

###### 개발자의 결을 설명하는 4가지 색

1) 파랑

- 프로그래밍에 대한 재능을 타고 났으며, 노력까지 기울이는 사람의 색이다. 잘 알려진 오픈 소스 프로젝트를 주도하거나, 새로운 패러다임을 제시하거나, 고전에 속하는 책을 쓰거나, 컨퍼런스에 단골로 초대되는 사람들이다. 회사에서 일할 때만이 아니라 밥을 먹거나, 길을 걷거나, 차를 타거나, 친구를 만나거나, 심지어 잠을 잘 때도 코딩 방법을 궁리한다. 진심으로 코딩이 게임이나 섹스보다 즐거운 사람들이다.

<br>

2) 노랑

- 프로그래밍에 대한 재능은 특별히 없지만, 노력만큼은 파란색 못지않게 기울이는 사람들이다. 회사에서 주어진 일에 온 힘을 다하고, 문제가 생기면 스스로 책임을 지려고 하고, 새로운 기술이나 동향에 항상 관심을 갖고, 좋은 책을 찾아서 부지런히 읽고, 동영상 강의나 팟캐스트를 찾아서 듣고, 오프라인 모임이나 컨퍼런스에 참여한다. 친구들과 코딩에 대해서 이야기하기를 즐기고, 회사에서 승진하거나 더 많은 책임을 맡는 것에서 성취감을 맛보는 사람들이다.

<br>

3) 빨강

- 빨강은 노랑과 반대다. 프로그래밍에 대한 재능은 타고 났지만, 노력을 기울이지 않는 사람들이다.

<br>

4) 검정

- 프로그래밍에 대한 재능이 없고, 노력도 하지 않는 사람들이다.

<br>

### 나프다! 배우고, 즐기고, 해결하고, 공유하라

- 개발자 문화는 배움(Learn), 즐김(Enjoy), 해결(Solve), 공유(Share)라는 네 개의 속성으로 정리할 수 있는데, 영어의 앞 글자를 따면 LESS다.
- 개발자 문화를 정의하는 속성 중에서 으뜸은 배움이다. 배움 없이는 개발자 문화를 말할 수 없다.
- 개발자의 본령은 문제를 해결하는 데 있다. 문제를 해결하지 못하면 개발자가 아니다.
- 진정한 개발자에게 지식과 경험은 경쟁의 수단이 아니라, 즐김을 위한 수단이기 때문에 나눔이 자연스럽다. 나눌 수밖에 없다. 나눌 때 즐거움이 증폭되기 때문이다. 나눌 줄 모르는 개발자는 즐길 줄 모르는 사람이다. 즐길 줄 모르기에 배움이 빈약하다. 배움 자체를 목적으로 삼지 않기 때문에 문제를 해결하는 능력도 부족하다.
- 개발자 문화의 진정한 핵심은 공유다. 배움과 즐김과 해결의 끝은 공유다.

<br>

### 개발자가 알아야 하는 것

- 더 많이 알수록 자기가 모르는 것이 얼마나 많은지 알게 되는 것이 개발자의 숙명이다.
- 많이 아는 것처럼 보이는 사람은 단지 해당 분야에 대해서 더 많이 알아야겠다고 결심하고 그 지점에서 균형을 맞춘 사람일 뿐이다.
- 자기가 이미 하고 있는 분야, 혹은 잘 알고 있는 분야에 집중해서 우물을 파듯 최대한 깊이 들어가라. 들어가서 물이 아니라 원리를 퍼올려라. 그렇게 파올린 원리를 조금씩 다른 분야에 적용해보라.
- 하수는 자잘한 구현에 집중하고, 고수는 언제나 원리에 집중한다.
- 내 마음속에서 생긴 흥이 흘러가는 대로 내 몸을 맡겨라.

<br>

### 프로그래머의 윤리학

- 프로그래머 윤리의 핵심은 다크패턴을 인식할 수 있는 능력, 그리고 그런 것을 개발해달라는 주문을 단호하게 거부할 수 있는 양심이다.

<br>

### 개발자를 위한 아는 척 매뉴얼

- 현업 프로그래머로 일하다 보면 홍길동이 되는 경우가 있다. 모르는 것을 모른다고 말할 수 없는 경우를 만다는 것이다. 때로는 모르는 것을 아는 척 넘어가고, 잘 기억해두었다가 나중에 공부하는 것이 현실적이다.
- 사실 아는 척을 잘하는 것은 개발자에게 실력의 일부다. 거짓과 사기의 영역으로 일탈하지 않는 한 그것은 의사소통에서 윤활유 역할을 하기도 하고, 개발자의 몸에 흡수되는 영양분이 되기도 한다.
- 누군가 불안한 눈빛으로 아는 척을 할 때, 추궁하지 말고 즐겁게 속아주자.

<br>

### 개발자를 위한 10가지 철학

1) 그대 자신을 증명할 필요가 없다.

- 개발자는 회사에 얼마나 큰 기여를 하는지 증명할 필요가 없다.

<br>

2) 그대는 단순한 상품이 아니다.

- 프로그래밍은 개발자 고유의 개성이 살아 숨 쉬며 중요한 역할을 담당하는 창조적 노동이기 때문에, 개발자 A를 B로 손쉽게 대체할 수 없다. 회사가 그럴 수 있을 것처럼 행동하는 것은 엄포에 불과하며, 개발자가 회사를 떠나면 똑같은 사람을 시장에서 쉽게 구할 수 없음을 안다.

<br>

3) 소프트웨어 엔지니어링은 기술(art)과 과학(science)의 두 측면을 갖지만 두 개가 공존하는 경우는 거의 없다.

- 기획이나 설계 단계에서 개발은 기술이고, 일단 설계가 완료되면 나머지 작업은 일정한 규칙을 따르면 동일한 결과를 낳는 과학에 가깝다.

<br>

4) 그대와 그대의 직업은 동일한 것이 아니다.

- 직업은 우리가 가진 더 높은 목적을 이루기 위한 수단에 불과하다.

5) 세상은 분산 시스템이다.

<br>

6) 그대는 로또가 아니다.

- 운에 기대지 말라. 운이라는 것은 최선의 노력을 기울이지 않았을 때 마음의 위안을 얻기 위해서 기대는 언덕일 뿐이다.
- 핵심은, 온 힘을 다해서 노력하지 않으면서 욕망만 키우지 말라.

<br>

7) 계획보다는 행동이다.

- 행동은 계획이 없어도 성립할 수 있지만, 계획은 행동이 없으면 성립할 수 없다. 행동이 더 중요하다.
- 세상 사람들이 그대의 말에 귀 기울이지 않는 이유는, 말 그 자체는 행동이 아니기 때문이다.

<br>

8) 소프트웨어 엔지니어링은 그대를 착취하려는 자들의 거짓말로 가득 차 있다.

<br>

9) 그대는 학력 혹은 과거에 의해서 규정되지 않는다.

- 학력은 모욕까지는 아니지만, 최소한 거추장스럽다.
- 제대로 된 코딩을 할 수 있는 개발자라면 학력은 의미가 없다.
- 분명한 것은 개발이 가방에 대학 졸업장을 넣은 채 양복을 입고 하는 점잖은 일이 아니라는 점이다. 개발은 팬티만 입고 옥타곤에 올라가서 맨몸으로 싸우는 거다. 대학 졸업장이 줄 수 있는 도움은 아마 터진 코피를 닦는 일뿐일 것이다.

<br>

10) 소프트웨어 엔지니어로서의 그대는 최악의 경우라는 것이 근본적으로 제한되어 있기 때문에 마음껏 모험적인 선택을 내릴 수 있다.

<br>

## 5부 미래 - 해커의 길

- 마이어가 보기에 애자일과 스크럼은 관리자가 개발자를 통제하기 위한 수단에 불과하다. 진정한 개발자는, 혹은 해커는, 통제를 거부하고 가장 중요한 문제를 해결하기 위해서 코딩에 전념하는 사람이다.
- 해커는 꿀벌이다. 개발자를 '관리'하는 일은 양봉장에서 벌을 키우는 것과 비슷하다. 관리자는 멋대로 날아다니는 개발자를 통제할 수 없다. 오히려 어설프게 행동하다가 침에 쏘이는 일을 걱정해야 옳다. 그들이 하고 싶은 일을 하도록 내버려두면 어쨌든 꿀은 생산된다. 관리자의 목적은 꿀벌을 통제하는 것이 아니라, 꿀을 얻는 것이다. 해커는 꿀을 만들어내는 과정 자체를 즐기고 사랑한다. 어떤 종류의 통제나 절차도 그들과 어울리지 않는다. 다른 사람의 눈치를 보는 것은 해커의 본분이 아니다. 해커의 머릿속엔 코드만 들어 있다.

<br>

### 개발자를 위한 2015년 전망

- 실제 세상의 언어를 익히는 과정은 궁극적으로 낯선 문화를 이해하는 것으로 귀결된다. 마찬가지로 프로그래밍 언어의 학습은 새로운 생태계를 익히는 과정으로 수렴한다.
- 데이터는 그 자체로는 아무 의미를 갖지 않는다. 이모저모로 분석되어 비즈니스의 목적에 유의미한 정보가 추출되었을 때, 혹은 미래에 대한 판단이나 예측을 수행할 수 있을 때에 한해서 의미를 갖는다.

<br>

### 폴리글랏의 시대

- 개발자에게 있어서 통섭의 다른 이름은 폴리글랏이다. 서로 다른 것들이 합쳐지면서 새로운 활로를 개척하는 것이 통섭이다.

<br>