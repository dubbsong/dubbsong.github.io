---
layout: post
title: "대살개문"
categories: dev
tags: books
---

## 대한민국을 살리는 개발자 문화

###### 임백준 저

<br>

#### 지은이의 말

- Learn(배우고), Enjoy(즐기고), Solve(해결하고), Share(공유하라). 이렇게 네 가지 속성을 모으면 그게 개발자 문화다.

<br>

## 1부 현실 - 야근은 미친 짓이다

- 프로그래머가 정신을 집중해서 양질의 코드를 만들어낼 수 있는 시간의 최대치는 하루에 2~3시간이라는 것이 정설이다.
- 프로그래밍은 '양'의 노동이 아니라, '질'의 노동이다. 손가라기 아니라 머리로 하는 일이다.
- 프로그래밍 할 때 프로그래머의 두뇌는 CPU 레지스터와 메모리의 확장된 버전이 된다. 수많은 변수의 상태와 상호작용이 두뇌에 기억되고, 각종 클래스와 패키지 이름, 구현해야 하는 알고리즘의 개요, 다른 하위 시스템과의 상호작용, 방금 수정한 버그의 내용, 사용자 요구 사항 등이 모두 기억된다. 1차원적인 기억의 문제가 아니다. 기억한 내용이 서로 다차원적인 방식으로 상호작용하는 것을 실시간으로 파악하고 판단해야 한다. 엉망으로 꼬이고 엉킨 실타래의 끝을 놓치지 않고 추적하는 것이다.
- 에너지가 고갈된 상태에서 정상적인 코드를 만들기는 불가능하다.
- 프로그래머라면 하루에 2시간 이상 코드를 생산할 수 없다고 해서 조금도 자책하지 않기 바란다.

<br>

### 불안은 S/W 프로젝트를 잠식한다

- 시스템의 전체적인 그림을 크게 그려놓고 그에 수반되는 사항을 일목요연하게 정리한 아키텍처도 부재했다. 최종 제품을 얼마나 많은 사용자가 사용할 것인지, 얼마나 많은 데이터가 발생하는지, 반응 속도가 어느 정도로 빨라야 하는지, 보안 수준은 어느 정도로 구현해야 하는지, 하드웨어 장비는 무엇을 쓸 것인지, 통신 프로토콜은 어떤 것으로 할 것인지, 플랫폼과 언어는 어떤 것으로 정할 것인지 등등.
- 불안에 휩싸여 있는 사람들에게 딱히 해줄 말도 없다. 다만 그들이 두려워해야 하는 것은, 사소한 '손해'나 알량한 '이익'이 아니라, 프로젝트의 총체적인 실패를 의미하는 '허접한 결과물'이라는 점을 지적하고 싶다.

<br>

### 우리나라 개발자들의 경쟁력과 실패할 권리

- 우리나라 개발자들이 잠재력을 발휘하지 못하는 이유를 나는 '실패할 권리'가 없는 사회 환경에서 찾는다. 아이디어를 가진 사람이 두려움 없이 도전할 수 있는 조건이 부재한 것이다.
- 성공이라는 꽃은 수없이 반복되고 누적되는 실패라는 거름을 먹고 자란다. '실패할 권리'가 없는 곳에는 성공도 없다.
- 프로그래머가 소프트웨어 개발과 관련된 일체의 의사결정 과정에서 주체가 되어야 한다. 소프트웨어의 속성을 이해하지 못하는 사람이 개발자를 종처럼 부리는 기이한 현상은 중단되어야 한다.
- 손에 비트와 바이트를 묻힌 채로는 일정한 수준 이상으로 진급할 수 없기 때문에, 스스로 코딩을 포기하는 사람도 있다.
- 실력이 좋은 프로그래머는 실력이 좋은 다른 프로그래머를 사랑한다. 함께 일하는 것이 즐겁기 때문이다.
- 자기 아이디어를 실현하려고 노력하다가 장렬히 실패한 과거를 대기업에 입사했던 기록보다 더 자랑스러워하는, 실패할 권리와 자유가 강처럼 넘쳐흐르는 사회를 꿈꾸어본다. 그런 문화가 형성되지 않는다면 '우리나라 개발자들의 수준'을 '세계 수준'에 비교하는 것은 의미가 없다.

<br>

### 나는 프로그래머다

- 대한민국의 소프트웨어 업계는 갈라파고스다. 재능과 열정이 있는 사람들이 모여들고, 이익을 좇는 자본이 분주하게 돌아다니고, 기상천외한 아이디어와 문화가 풍성하게 꽃을 피우는 해외 각국의 소프트웨어 업계의 현실과 괴리되어 있는 섬이다.

<br>

### 프로그래머에게 자격증은 모욕이다

- 자격증을 획득하는 것은 진짜 '실력'을 쌓는 일과 아무런 상관이 없을 뿐만 아니라, 심지어 진짜 실력을 쌓는 행위를 가로막고 억압하는 장치에 불과하다.
- 진짜 실력은 자격증을 따기 위해서 '공부'할 때 쌓이는 것이 아니라, 일과 놀이가 구분되지 않는 상태에서 프로그래밍에 몰입할 때 생긴다.
- 자격증을 따기 위한 공부에도 순기능은 존재한다. 몰랐던 사실을 알게 될 수도 있고, 제한적이긴 하지만 디버깅 방법이나 프로그램 설계 기술을 익힐 수도 있다. 그렇지만 그런 단편적인 지식은 실력을 구성하는 요소에서 작은 부분에 불과하다.
- 프로그래밍을 체계적으로 배우지 않고, 학원에서 속성으로 학습한 사람들은 자신의 약점을 내면화한다.
- 실력이 있으면 누구나 개발자가 될 수 있다. 다만 원하는 직장을 얻으려면 자신의 능력을 자격증을 통해서가 아니라 실제로 문제를 해결하는 능력을 통해서 보여줄 수 있어야 한다.

<br>

### 마이너리그에 속한 개발자를 위하여

- 고담 시티에 사는 개발자들은 이렇게 멋진 컨퍼런스에 참석할 여유가 없을 거라는 사실을 깨닫는 데는 오랜 시간이 필요하지 않았다.
- 한국의 개발자 세계는 메이저리그와 마이너리그로 엄격하게 분리되어 있다. 삼성, LG 같은 대기업, 카카오, 쿠팡 같은 잘 나가는 벤처기업 등 소수의 회사가 메이저리그를 형성한다. 개발자들의 수준도 높고, 연봉도 괜찮고, 하는 일도 재밌다. 이러한 회사들은 속속 판교로 모여들고 있다고 한다.
- 실력에 자신이 있는 사람은 마이너리그를 떠나서 프리랜서가 되고, 운이 좋으면 메이저리그에 입성하기도 한다. 하지만 소수다.
- 문화는 상호작용의 결실이다. 풍성한 하위문화가 넘쳐흐르지 않으면, 엘리트 문화도 꽃을 피우지 못한다.

<br>

### 삼성 소프트웨어 직군 테스트

- 회사의 목적은 효율성을 통한 이익의 극대화이기 때문에, 자기 적성에 맞지 않는 일을 하는 사람들을 찾아서 다른 부서에 배치하는 것이 당연하다는 논리다.
- 회사의 목적은 민주주의와 복지가 아니라, 이익창출이다.
- 누군가에게는 며칠 밤을 새울 정도로 재밌고, 평생을 바쳐도 아깝지 않은 열정의 대상인 프로그래밍을, 한순가의 코딩 테스트로 전락시킨 사건이다.
- 축구 감독은 선수들이 '시험'을 치르게 만드는 것이 아니라, 감독 스스로 선수를 알아볼 수 있는 안목을 기르기 위해서 노력한다. 그게 감독의 일이다. 진짜 선수는 특정한 테스트를 의식하지 않고, 진짜 감독은 테스트를 필요로 하지 않는다.
- 삼성은 자기가 감당해야 하는 몫을 직원들에게 전가했다는 점에서 비판을 받아야 한다. 80%가 합격할 정도로 '쉬운' 시험이었다지만, 본질은 선착순처럼 잔인하다.

<br>

### 소프트웨어 개발자는 전기 양의 꿈을 꾸는가

- 컨디션이 좋은 날은 머릿속에 펼쳐지는 코드의 추상 수준이 끈 풀린 풍선처럼 하늘로 올라간다. 깔끔하고 명쾌하게 연결되는 코드가 쏟아진다.

<br>

### 개발자에게 부탁하라

- 자본주의 사회에서 트래픽은 광고와 직결된다. 풍부한 트래픽은 높은 광고 수익을 의미하고, 빈곤한 트래픽은 낮은 광고 수입을 의미한다.
- 인터넷, 디지털, 모바일, 소프트웨어 시대에서 주인공은 개발자다.
- 기술 수준이 높은 개발자를 고용해서 팀을 구축하고, 그들이 회사 내부에서 마음껏 일을 저지르도록 장려해야 한다.
- 트래픽에 연연하는 것을 속물이라고 비난해서는 곤란하다. 모든 일은 사람이 모인 곳에서 시작되기 때문이다.

<br>

### 조인트 맞는 개발자

- 개발자를 개발자답게 대접하지 않으면, '갑'도 소프트웨어 답지 않은 소프트웨어를 손에 넣을 수밖에 없다.
- 개발자가 즐겁지 않은 사회의 미래는 없다.

<br>

## 2부 - 문화 - 만나고, 마시고, 토론하라

- 반응형(reactive) 시스템이란 응답속도(responsiveness), 확장성(scalability), 이벤트 주도(event-driven), 그리고 유연성(resilient)이라는 네 가지 개념을 하나로 아우르는 새로운 패러다임이다.
- 소프트웨어를 개발하는 업무에 종사하다 보면 여러 가지 희열을 맛보게 된다. 좋은 사람들을 만나서 서로의 관심사를 나누는 것은 그중에서도 으뜸이다.
- 매일 똑같은 책상에 앉아서 똑같은 생각만 하는 사람은 실력이 늘기 어렵다. 실력도 실력이지만 프로그래밍이 무척 재미있는 일이라는 사실을 느끼지 못하게 된다.
- 친구들을 만나고, 마시고, 토론하라. 그런 만남과 토론 자체가 프로그래밍이라는 행위의 일부이다.

<br>

### 오픈 소스를 넘어서. 개발자의 재능 기부

- 컴퓨터 프로그래밍 세계에서는 오픈 소스 프로젝트에 참여해서 누구나 무료로 사용할 수 있는 소프트웨어를 제작하는 것이 말하자면 일종의 봉사에 해당한다. 오픈 소스는 재능을 기부하는 것이고, 지식을 나누는 행위다.
- 오픈 소스는 프로그래밍을 진심으로 사랑하는 해커들이 자기들끼리 모여서 여는 축제라는 성격이 강하다. 사회가 필요로 하는 소프트웨어를 만드는 것이 아니라, 해커들이 필요로 하는 도구를 만드는 경우가 대부분이다.

<br>

### 5000억 원짜리 버그

- 버그는 프로그래머의 숙명이다. 김밥을 마는 손에 밥풀이 묻는 것처럼, 비트와 바이트를 만지는 손에는 버그가 달라붙는다.
- 불완전함은 인간이 가진 자연스러운 속성의 하나이기에, 키보드를 두드리는 사람의 손끝에서 버그가 쏟아져 나오는 것은 자연스러운 일이며, 현대 프로그래밍 방법론의 한계이다. 그래서 버그가 있느냐 없느냐는 논의의 대상이 될 수 없다. 그것이 얼마나 자주 발생하는지, 그것으로 인한 피해가 어느 정도인지를 문제로 삼을 수 있을 뿐이다.
- 버그는 자신을 탄생시킨 사람을 충격과 공포의 도가니로 몰아 넣는 잔인하고 배은망덕한 존재지만, 동시에 사람을 단단하고 강하게 만드는 채찍의 역할도 담당한다.
- 몇 가지 기술적인 교훈이 있다. 우선 사용되지 않는 낡은 코드를 반드시 삭제해서 없애야 한다는 점이다. 실행 파일만이 아니라, 소스 코드에도 적용되는 이야기다. 어떤 프로그래머들은 삭제해서 없애야 하는 이전의 논리를 주석 처리를 해서 남겨놓거나, 심지어 if 구문을 통해서 우회한다. 상당히 나쁘고 위험한 습관이다.
- 문서, 절차, 검토, 확인, 테스트와 같은 부가적인 행위들이 때로는 불필요한 요식행위처럼 느껴지기도 하지만, 때로는 불완전한 존재인 우리에게 도움을 주기도 한다는 점을 기억하자.
- 우리가 오늘 작성한 코드 안에도 버그는 살아서 숨 쉬고 있다.

<br>

### 정치보다 강한 소프트웨어의 힘

- 변하지 않는 요구 사항은 세상에 존재하지 않는 법이기 때문에 문제가 될 수 없다. 변하는 요구 사항을 제대로 수용하지 못하는 프로젝트가 있다면, 문제는 그 프로젝트이다.
- 프로젝트의 성공이 의미하는 바가 불명확하다면, 그것은 수사학에 불과하다. 많은 사용자가 동시에 웹 사이트에 들어와서 회원가입을 하고 무언가 선택할 수 있으면 프로젝트는 성공이고, 그렇지 않으면 실패다.
- 테스트라는 것은 나중에 몰아서 한꺼번에 수행하는 것이 아니라, 설계와 구현 자체와 뗄 수 없는 방식으로 결합되어 있는 '개발 과정'의 핵심적인 일부이다.
- 많은 방문자를 상정한 웹 사이트는, 기본적이고 핵심적인 기능을 갖춘 상태에서 베타 버전을 오픈해서 사용자들이 실제로 사용을 하도록 만드는 과정을 밟아야 한다.

<br>

### 창업국가의 비밀

- 컴퓨터 프로그래밍이라는 고도의 지적 노동은 일체의 정신적 억압으로부터 자유로운 당돌함과 자유를 바탕으로 한다.
- 지금 우리에게 필요한 것은 상식의 회복이다. 공동체에 대한 믿음이다.

<br>

### 신은 디테일 속에 존재한다

- 스티브 잡스나 알렉스 퍼거슨 같은 당대의 일인자들은 타인의 시선을 떠나서 스스로의 완벽함을 추구하기 위해 디테일에 집착했다.
- 누가 보고 안 보고는 정성을 들이는 이유와 아무런 상관이 없다.
- 디테일이 살아 있고, 빠르고, 안정감 있게 동작하는 코드를 작성하는 것은 `능력`의 문제인 경우가 많지만, 때로는 `태도`의 문제이기도 하다.
- 완성의 기준은 타인의 시선이 아니라, 자신의 내면에서 울리는 목소리가 되어야 한다.

<br>

### 어떻게 프로그래밍을 배울 것인가

- 프로그래밍은 이렇게 배우는 것이다. 노는 거다. 공부가 아니다. 경쟁이나 성적이라는 굴레로 가둘 수 없다.

<br>

### 구글에 취직하는 방법

- 구글이 직원을 채용할 때 주목하는 부분은 무엇일까? 숫자로 표현되는 외형적인 '스펙'이 아니라, 소프트 기술(soft skill)이라고 불리는 자질이다. 프로그래머의 실력을 파악하기 위해서 코딩 실력을 확인하는 것은 물론이지만, 그밖에 리더십, 지적 겸손(intellectual humility), 협동(collaboration), 적응력(adaptibility)과 같은 자질을 중시한다. 이런 자질은 학교 성적이나 브랜드와 직접적인 함수 관계가 없다.
- 가장 중요한 자질은 지적 겸손이다. 타인의 아이디어를 인정할 수 있는 능력이고, 실수로부터 배우는 능력이다.
- 구글은 특정한 기술을 깊게 아는 것을 뜻하는 '전문성(expertise)'에 낮은 비중을 둔다. 전문성보다는 부족한 정보를 토대로 최선의 판단을 내리는 적응력이 중요하다. 새로운 지식을 빨리 흡수해서 자기 것으로 만드는 능력이 더 중요하다. 지식이 아니라 메타 지식이다.
- 프로그래머가 다루어야 하는 정보의 양이 과거에 비해서 비교할 수 없을 정도로 많고, 의미 있는 소프트웨어를 개인이 만드는 것이 아니라 팀이 공동으로 작업해야 하는 요즘에는 새로운 것을 빨리 습득할 수 있는 능력을 갖춘 프로그래머가 요구된다.
- 타인의 아이디어가 자기 생각보다 낫다고 판단되면 즉각적으로 수용할 수 있는 능력이 있어야 하고, 실수를 부끄러워하는 것이 아니라, 실수로부터 배우기를 즐기는 사람이어야 한다.
- 어떤 언어를 얼마나 알고 있는가 하는 것보다, 어떤 언어를 얼마나 빨리 배울 수 있는가 하는 것이 더 중요한 시대가 되고 있다.
- 지식보다 메타 지식이 중요해지는 시대의 흐름을 정확하게 읽고 있는 것이다.

<br>

### 우리도 가상 모임을 시작하자

- 중요한 것은 문화다. 문화는 흙이고, 기술은 꽃이다. 기술은 문화라는 흙을 먹고 자라는 꽃이다.

<br>

### 늙은 개발자의 노래

- 프로그래밍에 젊음과 열정을 바친 사람들은 40세 생일을 맞이한 이후에 모두 어디로 가서 무엇을 하는 것일까?
- 늙은 개발자의 노래 소리가 들리게 만들어라. 노래 소리가 충분히 크게 들리면, 아이들은 자연스럽게 SW에 관심을 갖고 모여들 것이다. 나이 든 개발자들은 노래를 부르면서 어린 아이들에게 코딩을 가르치고, 젊은 개발자들에게 지혜를 나누어줄 것이다. 진짜 SW 교육은 그런 것이어야 한다.

<br>

### 페이스북의 다운과 자동화의 덫

- 컴퓨터 시스템은 데이터베이스에 저장되어 있는 데이터를 메모리에 올려놓고 사용하는 경우가 많다. 로그인 요청과 같은 사용자 질의가 들어오면 멀리 있는 데이터베이스에 갈 필요 없이 메모리에 있는 데이터를 읽고 서비스를 제공하면 처리 속도가 빨라지기 때문이다. 이때 메모리에 저장된 데이터를 `캐시`라고 부른다. 캐시는 임시적인 값이기 때문에 데이터베이스에 있는 값이 변경되면 새로 갱신을 해주어야 한다.
- 시스템의 안정성을 뽐내던 페이스북이 다운되었다는 소식은 순식간에 온라인을 뜨겁게 달구었다. 페이스북은 이미 단순한 소셜 네트워킹 서비스가 아니라, 실제 서비스를 제공하는 플랫폼으로 자리를 잡은 상태이기 때문에 긴 장애시간은 온라인과 오프라인을 아우르는 일대 사건이었다. 문제의 원인은 비교적 간단했다. 페이스북은 캐시의 값을 갱신해주는 작업을 자동화했다. 캐시의 값이 정상적인지 여부를 판단하고, 정상적인 값이 아니면 데이터베이스에서 새로운 값을 읽어서 캐시의 값을 갱신하는 코드를 작성한 것이다. 그런데 사소한 실수로 인해서 그 값에 오류가 있었다. 데이터베이스에 있는 값이 캐시에 저장되자마자 자동화된 캐시 갱신 코드가 동작을 개시했다. 코드는 캐시 값이 정상적이지 않다고 판단하여 그 값을 데이터베이스에서 읽어들이는 작업을 수행했다. 하지만 이 작업이 엄청나게 많은 사용자를 대상으로 동시에 이루어졌기 때문에 데이터베이스는 초당 수십 만에 달하는 질의를 받고 마비되었다. 새로운 값을 읽었다고 해도, 데이터베이스에 저장되어 있는 값 자체가 오류를 담고 있었기 때문에 캐시를 갱신하는 작업은 무한히 반복되었다. 페이스북 기술자들은 무한히 반복되는 코드를 멈추려고 애썼지만, 그렇게 할 수 없었다. 유일한 방법은 시스템 전체를 멈추고, 자동화된 캐시 갱신 코드를 제거하고, 시스템을 다시 시작하는 방법밖에 없었다. 소프트웨어 개발자라면 알겠지만, 가장 치욕적인 해결 방법이다. 그 작업을 수행하는 데 걸린 시간이 2시간 30분이었다.

<br>

## 3부 기술 - 저물어가는 프로그래밍의 시대

- 우리가 방문하는 웹 사이트의 대부분은 사람이 아니라 기계가 만든 장소로 변하게 될 것이다.

<br>

###### 함수형 프로그래밍이라는 유령

- 함수형 패러다임을 구성하는 개념들은 실제로 상당히 추상적인 수학적 개념을 바탕으로 한다.

<br>

### 함수형 프로그래밍을 통한 간결한 코딩

- "함수형 프로그래밍은 모듈의 경계를 어디쯤으로 정해야 하는지, 모듈의 재사용성을 어떻게 향상시킬 수 있는지 등에 대해서 전과 다른 방식으로 사고하게 만들었다. 엄청난 분량의 데이터를 다루고, 빠르게 변하는 요구 사항에 대응하고, 급박한 일정 속에서 일해야 하는 현대 프로그래밍 고유의 문제들을 해결하는 데 있어서 함수형 프로그래밍이 매우 유용하다는 결론을 내리게 되었다." <자바 개발자를 위한 함수형 프로그래밍>, 딘 왐플러
- 왐플러가 전달하고자 하는 메시지의 핵심은 특정 언어와 관련된 것이 아니라, 함수형 프로그래밍이라는 패러다임 일반과 관련이 있다. 예컨대 자바나 C#처럼 함수형 언어가 아닌 명령형 언어를 사용한다고 해도 프로그래머가 이미 함수형 프로그래밍의 세례를 받고 난 이후라면 함수형 프로그래밍을 몰랐던 과거에 비해서 비교할 수 없을 정도로 '간결한' 코드를 작성할 수 있다는 말이다.
- 자바에서 Map이나 HashMap으로 표현하는 데이터구조가 C#에서는 Dictionary라는 이름으로 불린다.

<br>

### NoSQL의 기원

- 붕어빵에 붕어가 없듯이, NoSQL은 SQL에 대한 것이 아니다. NoSQL은 관계형이라는 패러다임을 극복하기 위한 노력, 클라우드 컴퓨팅으로 대표되는 클러스터 환경에 맞는 데이터베이스를 만들려는 노력, 엄청난 분량과 속도로 생산되는 빅데이터를 처리하기 위한 노력, 미리 정의된 스키마를 사용하지 않으면서 데이터를 처리하고자 하는 노력 등을 하나로 묶어서 지칭하는 포괄적인 표현이다.
- NoSQL 운동은 관계형 데이터베이스의 종말을 의미하는 것이 아니다. 대신 컴퓨팅 환경에 새로운 차원의 문제가 주어지면서, 관계형 패러다임으로 모든 문제를 해결할 수 있는 시대가 끝났음을 알리고 있을 뿐이다.

<br>

### 액터 모델과 아카

- 멀티스레드 코딩은 프로그래머의 숙명이다.
- 아무리 실력이 뛰어난 프로그래머라고 해도 일일이 잠금장치(lock)를 이용해서 버그가 없는 멀티스레드 코드를 작성하는 것은 불가능하다. 불가능하다고 단언할 수 있는 이유는, 코드의 정확성을 수학적으로 증명할 수 없기 때문이다.
- 멀티스레드 코드는 작성하기도 어렵지만, 디버깅은 더 어렵다. 디버깅을 하기 위해서 개입을 하는 순간, 코드의 동작이 전과 달라지기 때문이다.
- 프로그래밍 세계에서는 디버깅하기 어려운 멀티스레드 관련 버그를 '하이젠버그(Heisenbug)'라고 부르기도 한다.
- 액터(actor)는 '스레드' 혹은 '객체'와 구별되는 추상이다. 액터가 차지하는 메모리 공간은 다른 스레드 혹은 액터가 접근할 수 없다. 다시 말해서 액터 내부에서 일어나는 일은 어느 누구와도 '공유'되지 않는다. '공유'라는 속성을 제거함으로써 멀티스레드와 관련된 문제의 대부분을 제거했다.

<br>

### 비트코인 채굴 방법

- 월스트리트는 모든 것을 거래한다. 주식, 채권, 금처럼 눈에 보이는 것만이 아니라, 날씨나 신용처럼 눈에 보이지 않는 것까지 거래한다. 이익을 남길 수 있다면 태양의 흑점까지 거래할 사람들이다. 이런 사람들의 눈에 비트코인처럼 떠들썩한 물건이 보이지 않을 리 없다.
- 펀드 매니저들이 비트코인을 거래한다는 것과, 그것이 화폐로서 인정을 받는다는 것은 별개의 문제다.
- 프로그래머라면 간단한 암호 원리와 '해시 함수'에 친숙하기 때문에 비트코인 채굴 과정이 구체적으로 어떤 작업으로 이루어져 있는지 이해하는 것이 어렵지 않다. 하지만 프로그래밍에 익숙하지 않은 사람에게는 이해할 수 있는 비유가 필요하다.
- 주머니 안에 1부터 1000까지 숫자가 적힌 공이 들어 있다. 눈을 감고 공 하나를 꺼내서 번호를 확인한다. 확인한 공은 다시 주머니에 넣고 흔들어서 섞는다. 이때 꺼낸 공에 적힌 숫자가 50보다 크면 같은 작업을 반복하고, 50보다 작으면 비트코인을 하나 획득하게 된다. 공을 꺼내고, 확인하고, 넣는 작업을 빠르게 반복하면 50보다 작은 수가 적힌 공을 꺼낼 가능성이, 즉 비트코인을 획득하게 될 가능성이 더 높아진다. 비트코인 채굴 ㄱ작업에 최적화된 하드웨어와 소프트웨어가 제작되는 이유다.
- 너무 많은 사람이 작업에 참여하거나, 성능이 좋은 하드웨어가 등장해서 비트코인이 당첨되는 속도가 빨라지면 '50보다 작은 수'라는 규칙에서 50을 20으로 낮추면 당첨자가 나오는 속도를 조절할 수 있다.
- 실제 비트코인 채굴 과정에서는 SHA-256이라는 해시 함수가 사용된다. 어떤 숫자나 텍스트를 입력하면 256비트로 이루어진 2진수 값을 출력하는 함수다. 비밀번호나 중요한 내용을 암호화하기 위해서 사용되는 함수로, 현존하는 방법 중에서 가장 강력한 것의 하나로 인정받고 있다. 이러한 해시 함수의 특징은 입력에서 출력으로 가는 과정은 순식간이지만, 출력된 내용으로부터 입력된 내용을 거꾸로 유추하는 것은 거의 불가능하다는 점이다. 그리고 동일한 입력에 대해서는 언제나 동일한 값을 출력한다.
- 채굴 작업을 시작하면, 비트코인 공식 사이트는 일정한 텍스트, 즉 SHA-256 해시 함수에 입력될 내용을 전달해준다. 그러면 채굴 작업을 수행하는 컴퓨터는 전달된 내용을 해시 함수에 넣고 실행한다. 이때 출력된 값이 공식적으로 정해져 있는 값보다 작으면 비트코인을 획득한 것이다. 채굴 작업을 수행하는 컴퓨터에서는 해시 함수를 실행하기 전에 공식 사이트에서 보내준 텍스트에 임의의 텍스트를 추가한다. 임의의 텍스트를 nonce라고 부른다.
- 결국 비트코인 채굴 작업은 임의의 텍스트, 즉 nonce의 값을 이리저리 바꾸어보녀서 정해진 값보다 작은 해시 값을 얻을 때까지 함수를 실행하는 과정을 의미한다. 이런 과정은 어려운 수학 문제를 풀기 위해서 공식이나 원리를 사용하는 것이 아니라, 1부터 1,000,000까지의 수를 일일이 대입해보는 것과 비슷하다. 무한히 반복되는 단순 노동의 끝판왕이다. 사용되는 전력과 컴퓨팅 파워를 고려해보면, 인류에게 그다지 유용한 일을 수행하는 것은 아니다.

<br>

### 핀테크, 돈의 흐름을 바꾸다

- 화폐의 본질은 정보다. 정보는 네트워크를 통해서 흐른다. 미래의 금융 서비스는 네트워크를 장악하는 회사의 손에 달려 있다.

<br>

### 머신러닝의 시대

- 우리말로 기계학습이라고 부르는 머신러닝은 통계학과 컴퓨터 프로그래밍이라는 두 개의 산줄기가 만나서 형성한 산맥이다. 핵심은 미래에 대한 예측이다. 곳곳에 존재하는 컴퓨터, 휴대폰, 센서, CCTV, 단말기 등이 뿜어내는 엄청난 양의 데이터를 분석해서 일정한 패턴을 찾아내는 통계의 마술이다.
- 아마존 홈페이지를 방문하면, 머신러닝 알고리즘은 나와 비슷한 통계적 속성을 가진 사람들이 구매한 책을 찾아내서 내 화면에 보여준다. 축적된 데이터를 이용해서 미래의 내가 어떤 책에 관심을 가질 지 예측하는 것이다.

<br>

## 문제는 알고리즘이다

- 알고리즘의 정의

> "A set of steps that are followed in order to solve a mathematical problem or to complete a computer process."
>
> "수학적인 문제를 해결하거나 컴퓨터 프로세스를 완결하기 위해서 차례로 뒤따르는 단계의 집합."

<br>

- 알고리즘은 어떤 문제를 해결하기 위해서 필요한 규칙을 이해하고, 그러한 규칙을 단계별로 적용해서 문제를 해결하는 것을 의미한다.
- '규칙을 이해하고, 그런 규칙을 적용해서 문제를 해결하는 것'이 바로 프로그래밍이다.
- 대학에서 학생들이 배워야 하는 것은 특정한 API를 다루는 '코딩' 능력이 아니라, 주어진 문제를 해결하기 위해서 규칙을 이해하고, 규칙을 단계별로 적용해서 문제를 해결하는 능력이다. 즉, 코딩이 아니라 알고리즘이다. 코딩은 알고리즘이라는 능력이 겉으로 드러나는 여러 가지 방식의 하나일 뿐이다. 코딩은 외공이고, 알고리즘은 내공이다.
- 요즘처럼 기술 변화의 속도가 빠른 시대에는 특정 기술, 플랫폼, 언어, API에 종속되는 코딩 기술의 가치가 전보다 크지 않다. 오히려 낡은 기술을 버리고 새로운 기술을 재빨리 익히는 능력이 중요하다.
- 알고리즘은 방향 전환을 가능하게 만들어주는 일종의 '메타 능력'이다.
- 프로그래밍이라는 기술은 알고리즘이라는 세포로 이루어져 있다. 알고리즘이라는 세포의 내부에 존재하는 DNA는 논리다. 만사에 논리적인 사람은 좋은 코드를 작성한다.
- 알고리즘이 얼마나 중요한가 하면, 프로그래밍 그 자체라고 말할 수 있을 정도로 중요하다. 문제는 알고리즘이다.

<br>

### 이세돌과 알파고

- 알파고의 내면은 인간의 흉내를 낸 신경망 알고리즘으로 이루어져 있다. 엄청난 규모의 데이터가 몇 개의 단계로 구분되어 있는 알고리즘을 거치면서 필요한 답으로 수렴된다. 시행착오와 실수를 겪으면서 스스로의 사고능력을 발전시킨다는 점에 있어서 인간과 닮았다.
- 인공지능을 연구하는 사람들은 알파고를 만들었지만, 그것이 어떤 원리에 의해서, 왜 그렇게 동작하는지 명쾌하게 설명하지 못하고 있다. 딥러닝 패턴을 인식하거나, 대규모 연산이 하나의 답으로 수렴하는 과정을 수학적으로 설명하지 못하는 것이다.

<br>

### 인공지능, 문제는 바둑이 아니다

- 알파고가 놀라운 점은 바둑 실력이 아니라 스스로 보고 배우는 능력이다. 무엇을 배울지 결정하는 것은 사람이지만, 얼마나 빠른 속도로 어디까지 배울지 정하는 것은 알파고 자신이다.

<br>

### 인공지능 시대의 도래

- 인공지능은 바다다. 이 거대한 바다 앞에서 리눅스와 윈도우의 구분 같은 것은 개울물에 불과하다. 자기가 선호하는 회사, 생태계, 테크놀로지 스택에 사로잡힌 채 집착하는 사람은 자기 미래를 제한하는 치명적인 실수를 저지르고 있는 것이다.

<br>

## 4부 개발자 - 멘토는 없다

- 멘토와 멘티라는 관계가 발설되는 순간, 두 사람 사이에는 암묵적인 권력 관계가 성립한다. 그런 권력 관계는 '물질적 이득'을 토대로 구축된다. 멘티 역시 멘토와의 관계 속에서 이득을 추구한다. '배움'이라는 완곡한 표현으로 포장되긴 하지만 권력 관계에 자발적으로 발을 들여놓는 멘티의 속마음도 이익을 얻는 데 집중된다. 멘토에 대한 인간적인 존경과 애정이 아니라 '그가 나에게 무엇을 줄 수 있는가'가 관심사다.
- 프로그래머들은 자기가 속한 팀에서 자기가 가장 실력이 낮은 사람이 되도록 애쓰라는 격언이 있다. 배울 사람이 없는 팀에서 오래 머물지 말라는 뜻이다.
- **프로그래밍은 책이나 수업보다 다른 사람의 작업을 어깨 너머로 보면서 배우는 것이 왕도**이기 때문에, 개발자들은 배우고 가르치는 관계에 갈증을 느낀다.
- 멘토는 없다. 스스로 마음을 일으키는 발심(發心)이 핵심이다. 발심을 개발자 용어로 달리 표현하면 '코딩신을 영접'하는 것이다.
- 굳이 누가 가르쳐주고, 누가 배우는지 구별할 필요가 없다. 가르치는 사람이 더 많이 배우기도 하고, 배우는 사람이 가르침을 주기도 한다.
- 코딩신을 영접한 사람의 눈에는 자신에게 가르침을 주는 친구가 사방에 출몰한다. 코딩신을 영접한 사람은 코딩신을 영접한 사람을 알아본다.
- 갈림길을 만나면 머리가 계산을 하기 전에 심장이 저절로 움직이기 때문에 다른 사람에게 물어볼 필요가 없다. 이미 행복하기 때문에 전망에 연연하지 않으며, 전망이 없으면 전망을 만들고, 길이 없으면 길을 만들겠다는 배짱과 낙관이 충만하다.
- 공부(工夫)에서 '공'은 하늘과 땅을 잇는 것을 표상한다. 그렇게 엄청난 일을 스스로 하지 않으면 누가 대신 해줄 수 있을까?
- 멘토에게 기대는 것은 자신을 속이는 일이다.

<br>

### 소프트웨어 개발자와 영어

- "내가 아는 언어의 한계가 곧 내가 사는 세상의 한계다." -비트겐슈타인
- 영어가 별다른 장애가 아닌 사람과, 영어 때문에 훌륭한 자료를 마음껏 활용하지 못하는 사람이 갖는 차이는 생각보다 크다.
- 인터넷에 무료로 존재하는 값진 자료들을 마음껏 활용할 수 있을 정도로 언어 능력의 지평을 넓혀야 한다. 그것은 선택이 아니라 필수다. 좋은 개발자가 되기 위한 최소한의 필요조건이다.

<br>

### 개발자의 불안, 당신만 그런 것은 아니다

- keep going

<br>