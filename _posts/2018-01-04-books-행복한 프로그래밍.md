---
layout: post
title: "행복한 프로그래밍"
categories: dev
tags: books
---

###### 임백준 저

<br>

- 내가 엔터키를 두드렸을 때 인터넷 익스플로러는 문자로 입력된 웹 사이트 주소를 근처에 있는 DNS 서버로 보내서 숫자로 된 주소 값(IP 주소)을 알아냈을 것이다. 다음에는 입력된 정보를 HTTP에 맞게 재구성하여 운영체제에 넘겨주었을 것이다. 네트워크를 담당하는 프로그램은 다시 그 정보를 패킷이라는 작은 조각으로 나눠서 컴퓨터에 연결된 랜선을 통해 컴퓨터의 바깥으로 내보냈을 것이다. 그러면 회사 내부의 네트워크와 바깥의 네트워크를 구분하는 관문(gateway) 역할을 하는 프록시(proxy) 서버의 주소를 알아낸 다음 그 패킷을 해당 웹 서버로 보냈을 것이다. 아직 더 남았다. 웹 서버가 실행되고 있는 컴퓨터의 운영체제인 유닉스 시스템은 자기에게 전달된 패킷을 모두 모아서 원래의 HTTP에 맞는 정보로 재구성한 다음 그 것을 아파치(Apache)라는 웹 서버로 전달했을 것이다. 아파치 웹 서버는 다시 그 정보를 프로그램에 전달했을 것이고, 프로그램은 그렇게 전달된 정보를 이용해서 HTML 문서를 만들고, 그것을 다시 아파치에게 돌려주었을 것이다. 이렇게 아파치에 전달된 HTML은 유닉스 시스템에 전달되어 작은 패킷들로 나뉘고, 그것이 컴퓨터의 시스템에 전달되어 원래의 HTML 문서로 재구성된 다음, 마침내 인터넷 익스플로러 화면 위에 나타나게 된 것이다.
- 현실 세계의 물질이 원자로 이루어져 있듯이, **사이버 세상의 물질은 비트로 이루어져 있다.**
- 복잡하고 정교한 논리의 체계가 단지 1과 0이라는 비트 두 개에서 출발하는 것과 마찬가지로, 강력한 연산 능력을 자랑하는 현대 컴퓨터의 육신은 불 대수를 구현하고 있는 논리 게이트에서 출발한다.
- 논리 게이트에는 'AND' 게이트, 'OR' 게이트, 'XOR' 게이트, 그리고 'NOT' 게이트 등이 존재하는데, **아무리 복잡하고 정교한 연산을 수행하는 반도체 칩도 모두 이러한 단순한 논리 게이트에서 시작한다**.
- 컴퓨터 시스템의 발전에 혁혁한 공을 세운 불의 이름을 잊지 않고 기억해두기 위해서 참(true)과 거짓(false) 중에서 하나를 값으로 갖는 자료형을 `불리언(boolean)` 혹은 `불(bool)`이라고 부르고 있다.
- 10진수를 2진수로 변환하는 알고리즘
  1. 주어진 수를 2로 나눈다. 만약 나눠떨어지면 땅에 1을 적고, 아니면 0을 적는다.
  2. 나누기 결과, 땅에 1을 적었으면 남은 수를 다시 2로 나눈다. 나눠떨어지면 땅에 적힌 수의 오른쪽에 1을 적고, 아니면 0을 적는다.
  3. 나누기 결과, 땅에 0을 적었으면 남은 수에 1을 더한 다음 2로 나눈다. 나눠떨어지면 땅에 적힌 수의 오른쪽에 1을 적고, 아니면 0을 적는다.
  4. 남아 있는 수가 0이 될 때까지 이 과정을 반복한다.
- 2진수의 원리는 비트의 법칙을 구성하는 기본적인 원리이다.

<br>

- **10진수 / 2진수 / 16진수**

> 0 / 0000 / 0
>
> 1 / 0001 / 1
>
> 2 / 0010 / 2
>
> 3 / 0011 / 3
>
> 4 / 0100 / 4
>
> 5 / 0101 / 5
>
> 6 / 0110 / 6
>
> 7 / 0111 / 7
>
> 8 / 1000 / 8
>
> 9 / 1001 / 9
>
> 10 / 1010 / A
>
> 11 / 1011 / B
>
> 12 / 1100 / C
>
> 13 / 1101 / D
>
> 14 / 1110 / E
>
> 15 / 1111 / F

<br>

- 비트의 법칙을 이해하기 위한 첫걸음은 2진수끼리 더하고 빼는 연산을 자유자재로 할 수 있는 기본을 닦는 일이다. 기본을 익히고 난 다음에는 곱하기, 나누기, 오버플로(overflow), 1의 보수(1's complement), 2의 보수(2's complement)와 같이 약간 고급스러운 개념을 공부한다.
- 2진수와 16진수 사이에 존재하는 재미있는 특성 하나는, 네 자리로 이루어진 2진수 수가 항상 한 자리의 16진수 수에 대응한다는 사실이다. 그렇기 때문에 기다란 2진수는 종종 16진수를 이용해서 간단하게 표시하기도 한다. 2진수 숫자로 가득 찬 컴퓨터 메모리의 내부를 흔히 2진수가 아니라 16진수로 나타내는 것이 대표적인 예다.
- '1101110001010010'과 같이 비트 16개로 이루어진 2진수를 16진수로 표현한다면, 2진수를 네 자리씩 끊었을 때 '1101'이 D에 해당하고, '1100'이 C에 해당하고, '0101'이 5에 해당하고, 마지막 '0010'이 2에 해당하므로, 'DC52'처럼 훨씬 간단하게 표기할 수 있다.
- `2^10 = 10^3`. **2^10은 1,024고, 10^3은 1,000이므로, 이 등식은 수학적으로 사실이 아니다.** 그러나 커다란 수를 많이 다루는 프로그래머들은 2진수와 10진수 사이의 복잡한 계산을 피하려고 이 공식을 즐겨 사용한다.

<br>

- 위 공식이 사용되는 예

> 한 번에 비트 32개로 이루어진 메모리 주소 공간을 다루는 컴퓨터를 보통 32비트 컴퓨터라고 부른다. 그런데 사람들은 비트 32개로 이루어진 2진수로 나타낼 수 있는 최대값이 '40억'이기 때문에 메모리를 최대 4GB까지만 지원할 수 있다고 말한다. 그러나 이것은 사실 정확한 표현이 아니다. 비트 한 개로 나타낼 수 있는 최대값은 1이고, 비트 두 개로 나타낼 수 있는 최대값은 11(10진수로 3)이며, 비트 세 개로 나타낼 수 있는 최대값은 111(10진수로 7)이다. 이러한 결과를 보면 비트의 수와, 그것으로 나타낼 수 있는 2진수의 최대값 사이에는 일정한 함수 관계가 존재한다는 사실을 알 수 있다. 즉, 비트의 수가 n이라고 했을 때, 그 수만큼의 비트를 이용해서 나타낼 수 있는 2진수의 최대값은 2^n-1이다. 그렇다고 한다면 비트 32개로 이루어진 2진수로 나타낼 수 있는 최대값은 다음과 같다.
>
> `11111111111111111111111111111111 = 2^32 - 1 = 4,294,967,295`
>
> 다시 말해서, **4GB라는 표현은 40억을 의미하기 때문에 실제로는 뒤에 붙어 있는 294, 967,295라는 엄청난 수를 생략하고 있는 것이다.**

<br>

- 256M(메가)는 실제로 2의 몇 승을 의미하는 숫자일까?

> 256M = 256 x 10^6 = 2^8 x 10^6 = 2^8 x (10^3)^2 = 2^8 x (2^10)^2 = 2^8 x 2^20 = 2^28
>
> 그런데 2^28을 실제로 계산한 값은 268,435,456이므로 256,000,000과 비교하면 무려 12,435,456만큼 더 크다. 여기에서도 마찬가지로 이상한 공식 덕택에 적어도 12MB정도는 허공에 날려버리는 것이다.

<br>

- 비트의 법칙에 익숙해져서 2진수, 8진수, 16진수와 같은 수의 체계 사이를 자유자재로 돌아다니면서 연산을 수행할 수 있게 되면 최소한 밥 짓고 빨래하는 일은 졸업하게 된다.
- 비트의 법칙을 이해하는 것은 어디까지나 프로그래밍의 아름다움을 감상하는 데 필요한 준비 작업이지, 그 자체가 목적인 시대는 지났다.
- 해바라기 씨앗의 배열을 닮은 피보나치 수열은 매우 아름답지만, 그것을 컴퓨터 프로그램으로 옮기는 것이 별로 어려운 일이 아니라는 사실은 나중에야 알게 됐다.
- 프로그래밍을 먹고 살기 위해서 어쩔 수 없이 하는 소외된 노동으로 만드는가, 아니면 자기를 실현하는 해방된 노동으로 만드는가는 자신에게 달려 있다.
- 프로그래머는 프로그래밍 언어를 익히고, 수학적 추론을 학습하고, 알고리즘을 작성하고, 프로그램의 속도를 분석한다.
- 피보나치 수열은 두 개의 1로 시작해서 앞의 두 수를 더한 수가 현재의 수가 되는 방식으로 진행된다.
  - 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...
- 피보나치 수열을 수학 공식으로 나타내면 다음과 같다.
  - F(n) = 1 (n <= 2)
  - F(n) = F(n-1) + F(n-2) (n >2)
- 피보나치 수열은 n의 값이 증가할수록 끝의 두 수 사이의 비율이 점점 황금비인 1.618..에 수렴하는 것으로 알려져 있다. 나무가 가지를 뻗는 모습, 소라나 고동의 집이 회오리 모양의 원을 그리며 가운데로 수렴하는 모습, 백화, 붓꽃, 채송화, 데이지와 같은 꽃잎의 개수, 은하계의 나선형 모양과 같은 자연 속의 사물은 물론, 담배갑의 가로세로 비율이나 배꼽을 중심으로 사람의 상체와 하체도 황금비를 이룬다.
- 프로그래밍 실력이 일정 수준에 도달한 사람은 대개 한 번쯤은 커누스 교수의 <컴퓨터 프로그래밍의 기술(The Art of Computer Programming)>을 찾는다.
- 프로그램을 처음 시작하는 사람이 주로 관심을 갖는 부분은 특정한 프로그래밍 언어의 문법과 API인 경우가 많지만, **프로그래밍의 본질은 프로그래밍 언어에 담겨 있는 것이 아니라 수학적 논리 체계, 즉 알고리즘에 담겨 있다.**
- `스레드(thread)`: 간섭을 받지 않고 독립적으로 수행되는 프로그램의 기본 단위
- 한 줄 서기 알고리즘은 `큐(Queue)`라고 불리는 자료구조가 사용하는 'FIFO(First-In-First-Out, 선입선출)' 알고리즘을 구현한 예라고 볼 수 있다.
- 접시가 쌓였다가 닦이는 과정을 생각해보면, 맨 나중에 들어와서 맨 위에 놓인 접시가 가장 먼저 닦인다는 사실을 쉽게 발견할 수 있다. 이러한 알고리즘을 구현하고 있는 자료구조를 `스택(Stack)`이라고 부른다.
- 단어를 찾을 때 단어를 지나쳤으면 앞쪽으로 페이지를 넘기고, 그렇지 않으면 뒤쪽으로 페이지를 넘길 것이다. 이러한 검색 방법은 `이진 검색(Binary Search)`이다.
- 프로그래밍이라는 일은 알고리즘을 만들어내는 과정과, 알고리즘을 프로그램으로 바꿔주는 두 부분으로 이뤄진다고 볼 수 있다.
- 프로그래밍 언어는, 비트의 법칙에 대한 깊은 이해와 언어학에 대한 통찰을 바탕으로 만들어지는 인공의 언어이다.
- 컴퓨터는 프로그래밍 언어로 작성된 프로그램을 있는 그대로 읽고 이해하지 못한다. 그 대신 프로그램 코드는 반드시 `컴파일러(Compiler)`라는 소프트웨어를 통해서 컴퓨터가 이해할 수 있는 언어인 이진 코드(Binary code)로 번역되어야 한다.
- 2진수 코드는 컴퓨터를 위한 언어이고, 프로그래밍 언어는 사람을 위한 언어이다.
- 프로그래머는 프로그래밍 언어를 이용해서 프로그램 코드를 작성하고, 컴파일러는 다시 프로그램 코드를 2진수 코드로 번역한다.
- "컴파일러를 작성하는 것은 프로그래밍 언어, 컴퓨터 아키텍처, 언어 이론, 알고리즘, 그리고 소프트웨어 공학의 문제로 확장된다." \- <Compilers: Principles, Techniques>
- 프로그래밍 언어의 의미를 해석하고, 문법을 검사하고, 코드를 최적화하는 컴파일러의 작업을 이해하려면 여러 주제를 학습할 필요가 있다.
- 컴파일러에서는 인식할 수 있는 단위 하나를 보통 `토큰(token)`이라고 한다.
- 컴파일러가 프로그램 코드를 해석하는 과정은, 주어진 입력(프로그램 코드)을 읽어 들여서 키워드와 일치하는지 혹은 언어의 문법에 부합하는지 확인하는 과정으루 이루어져 있다.
- 프로그램의 덩치가 커지고 복잡해지면, 논리상의 허점들이 프로그래머는 물론 컴파일러의 눈에도 쉽게 보이지 않게 된다.
- 알고리즘 하나하나는 치밀하고 완벽하게 작성된 것처럼 보이지만, 그러한 알고리즘이 모여서 만들어진 소프트웨어를 보면 전혀 예상하지 않았던 결과가 나타나기도 한다.
- Java, C#, Ruby, Python, Go 언어, 스칼라, JavaScript와 같은 일반적인 프로그래밍 언어를 비롯해서 리스프(LISP), 프롤로그(Prolog), 스킴(Scheme)과 같이 인공 지능(Artificial Intelligence) 분야에서 사용되는 언어들은 '고급(high-level) 언어'라고 하여 주로 사람이 읽기 편하도록 고안된 언어에 해당하지만, 특정한 컴퓨터 칩(CPU 혹은 마이크로프로세서)을 위해서 고안된 '저급(low-level) 언어'인 어셈블리(Assembly) 언어에서는 칩마다 서로 다른 언어를 가지고 있기 때문에 칩의 종류만큼이나 많은 언어가 존재한다.
- 내공이 부족한 프로그래머가 작성한 알고리즘은 대개 필요 이상으로 복잡하고 최적화도 고려되어 있지 않다.
- 알고리즘의 효율성에 관한 신중한 고민이 없이 작성된 프로그램은 실전 프로그래밍에서 심각한 문제를 일으킨다.
  - 프로그램의 성능을 저하시킨다.
  - 버그가 발생하도록 만든다.
- 프로그램 성능이란 대개 프로그램이 실행되는 속도를 의미한다.
- 실제 속도는 컴퓨터의 CPU 성능이나 메모리 용량과 같은 가변 조건에 의해서 달라지기 때문에 알고리즘의 속도를 분석할 때 보편적으로 이용할 수 없다. 그래서 알고리즘을 분석할 때에는 절대적인 값을 갖는 이론적인 속도가 더 중요하다.
- 이론적인 알고리즘 분석에서는 가상의 수 n을 수학적으로 좀 더 명확하게 정의하기 위해서 극한(lim)이나 빅오(Big-O), 스몰오(Small-O) 등과 같은 수학 함수를 사용한다.
- `시간`과 `공간`이라는 우주의 두 기본 축은 원자의 세계에서뿐만 아니라, 비트의 세계에서도 서로 직교하고 있다. 비트의 세계에 존재하는 알고리즘이 시간을 절약하기 위해서는 더 많은 공간이 필요하고, 공간을 절약하기 위해서는 더 긴 시간이 필요하다는 사실은 상식으로 통한다. 특정한 알고리즘이 더 빠르게 수행되도록 만들기 위해서는 일반적으로 더 많은 메모리 공간을 사용해야 하고, 그 반대로 메모리 공간을 최소로 사용하게 만들기 위해서는 알고리즘이 수행되는 속도를 일정 정도 희생해야 한다는 말이다.
- 부분적인 알고리즘이 아무리 효율적으로 작성되어 있더라도, 소프트웨어의 전체적인 설계가 엉망이거나, 프로그래밍 언어의 고유한 특성을 제대로 살리지 못한다면, 좋은 품질의 소프트웨어가 되기 어렵다.
- 성장하고자 하는 프로그래머는 수학적 추론이나 논리 능력을 키우는 것 외에도, 자신이 선택한 프로그래밍 언어의 속성과 기능들을 정확하게 파악하여, 그것을 자신이 고안한 알고리즘을 구현하는 데 정확하게 적용할 수 있도록 해야 한다.
- 빅데이터, 분산 컴퓨팅, 동시성 프로그래밍이라는 시대적 요청에 부응하기 위해서 함수형 프로그래밍 언어가 주목받는 요즘, JVM에서 클로저 언어와 더불어 자바의 대안 언어로 인식되는 스칼라는 기본적으로 함수 패러다임을 사용하는 언어이다. 하지만 자바를 이용하던 다수의 개발자들은 스칼라 언어를 사용해서 자바 코드를 작성한다.
- C를 사용하던 개발자가 자바를 접하면 객체 지향이라는 방법론, 자바가 해결하고자 했던 문제의 본질을 고민할 필요가 있다. 마찬가지로 자바를 사용하던 개발자가 스칼라를 접하면 함수 패러다임이라는 방법론, 그리고 스칼라가 해결하고자 했던 문제의 본질을 고민할 필요가 있다.
- 프로그래밍 언어를 익히기 위한 가장 훌륭한 방법은, 그것을 이용해서 실제 프로젝트를 수행함으로써 경험을 쌓는 것이다.
- C 언어는 프로그래머가 쉽게 이해할 수 있는 고급 언어 문법 구조를 지니고 있으면서도, CPU와 메모리라고 하는 비트의 세계 깊숙한 곳까지 들어갈 수 있도록 해주기 때문에, 엄청난 주목과 찬사를 받으면서 단숨에 1970년대와 1980년대를 관통하는 최고의 프로그래밍 언어로 등극했다.
- C 언어는 객체 지향 언어보다 절차 중심(procedure-oriented)의 언어라는 한계를 가지고 있다.
- 객체 지향 언어가 절차 중심의 언어보다 더 낫다고 볼 수는 없지만, 절차 중심의 언어가 해결하기 어려운 문제를 객체 지향 언어로 풀 수 있다는 점에서 그 둘의 차이는 분명히 존재한다.
- 절차적인 언어의 핵심은, 입력을 보내면 잠시 후에 출력 결과를 되돌려주는 함수라고 볼 수 있다.
- 프로그래밍을 익힌다고 하는 것은 패턴과 기법을 자기 것으로 만들어서, 어려운 문제를 풀 때 적절하게 응용할 수 있는 능력을 키우는 것이다.
- 복잡성 이론(Complexity Theory) 분야의 연구는 구체적인 알고리즘 개발과 직접적인 상관은 없지만, 어떤 문제가 쉽게 풀 수 있는 문제고, 어떤 문제가 쉽게 풀 수 없는 문제인지를 구별해준다.
- 속도를 분석할 때 n이라는 변수에 붙은 지수가 1이나 2처럼 미리 정해진 값, 즉 상수로 표현된다면 그 알고리즘을 쉬운 문제라고 간주한다.
- 지수의 값이 아무리 크다고 해도 그것이 미리 정해진 상수값이라면, 그 알고리즘은 컴퓨터가 적당한 시간 안에 계산해낼 수 있는 쉬운 알고리즘에 해당한다.
- 변수 위에 붙은 지수가 미리 정해진 상수인 수학 공식을 다항식이라고 부른다.
  - example) 2n^3 x n^2 - 3
- 복잡성 이론에서 다항식의 반대말은 '지수 함수'다. 지수 함수의 반대말은 로그 함수다.
- 지수 변수란, 변수 위에 붙은 지수가 미리 정해져 있는 상수값이 아니라, 그 자신도 변수로 표현되는 함수를 의미한다.
- 지수 함수의 예
  - 2^n
  - 2n^n-1 + 2^n
- 지수 함수의 특징은 n이 조금만 커지면 함수 전체의 값이 기하급수적으로 커진다는 사실이다.
- 지수 함수들은 n값이 커짐에 따라, 함수의 결과가 엄청나게 빠르게 증가하여 컴퓨터조차 쉽게 계산할 수 없다는 이유로, 이를 `어려운 문제`라고 한다. 즉, 알고리즘의 속도가 다항식이 아니라 지수 함수로 표현되면, 그것은 어려운 알고리즘인 것이다.
- 복잡성 이론에서는 알고리즘의 속도가 다항식으로 표현되는 문제들을 묶어서 'P'라 하고, 다항식으로 표현할 수 있는지가 알려지지 않은 문제들을 묶어서 'NP'라고 한다. 여기서 P는 polynomia(다항식)의 머리글자고, NP는 nondeterministic polynomial(비결정성 다항식)의 머리글자다. 이때 NP가 non-polynomial(비다항식)을 뜻하지 않는다는 점에 유의할 필요가 있다.
- 'NP-hard'라고 불리는 문제들은 모든 경우의 수를 전부 확인해보는 방법 이외에는 정확한 답을 구하는 뾰족한 수가 없는 문제를 뜻한다.
- 어떤 문제가 NP에 속하면서, 즉 다항식으로 표현할 수 있는지가 알려져 있지 않았으면서, 동시에 NP-hard에 속한다면 그 문제는 'NP 완전(NP complete) 문제'라고 한다. 비밀번호를 깨뜨리기 위한 해킹 과정도 NP 완전 문제에 속한다고 볼 수 있다.
- 비밀번호를 깨는 과정을 이해하려면 우선, ASCII(아스키) 문자 집합이라는 것을 알아야 한다.
- ASCII(American Standard Code for Information Interchange)란, 키보드로 입력하는 문자나 숫자, 혹은 특수 문자 128개를 일정한 숫자 값에 대응시킨 표준 테이블을 의미한다.
- 비밀번호는 결국 키보드로 입력할 수 있는 문자 128개 중에서 선택된 문자 몇 개로 이루어진다.
- 존 더 리퍼(John the Ripper)나 아울(Owl)과 같은 유명한 비밀번호 해킹 프로그램은 바로 사전식 공격(dictionary attack)에 기초를 두고 있다.
- 사전식 공격이란, 사전에 수록된 단어, 약자, 시사 용어, 유행어, 혹은 사람들이 비밀번호를 만들 때 흔히 사용하는 전형적인 패턴을 분석해서, 커다란 데이터베이스를 구축한 다음 비밀번호를 깨뜨리는 데 활용하는 것이다.
- 공개 키(public key)와 개인 키(private key)는 인터넷 뱅킹이 고객의 정보를 보호하기 위해서 사용하는 암호화 방식의 근간을 이루는 원리이다.
- 인터넷은 직행버스가 아니라 완행버스다. 즉, 내가 보낸 정보는 PC에서 은행 웹 서버로 곧바로 전달되지 않고, 중간에 많은 다른 서버를 거쳐서 전달된다. 그렇기 때문에 인터넷을 통해서 민감한 정보를 보낼 때는 반드시 암호화한 다음에 보내야 한다. 그리고 암호화하려면 반드시 키(key)가 있어야 한다.
- 암호화(encryption)와 해독(decryption, 복호화)을 동일한 키로 수행하는 기법을 `대칭형 암호화(symmetric encryption)`라고 하고, 공개 키와 개인 키를 이용해서 수행하는 기법은 `비대칭형 암호화(asymmetric encryption)`라고 한다.
- 비대칭형 암호화를 수학적으로 정의
  - 키 생성 함수(key generation function)에 의해서 공개 키인 K와 개인 키인 K^-1이 생성되었다고 하자. 암호화 알고리즘은 E라고 부르고, 해독 알고리즘은 D라고 부르자. 보내려는 정보, 즉 암호화되기 전의 평범한 텍스트(plain text, 평문)는 P라고 부른다. 암호화 알고리즘 E와 공개 키 K를 이용해서 P를 암호화한 문서는 E밑K(P)라고 표기한다. 이것은 암호화된 문서를 의미한다. 만약 해독 알고리즘 D와 개인 키 K^-1를 이용해서 암호화한 문서 E밑K(P)를 해독하면 그 결과가 원래 문서인 P가 되어야 한다. 이것을 수식으로 표현하면 다음과 같다.
  - D밑K-1(E밑K(P)) = P
  - 이런 조건을 `가역성(invertability)`이라고 한다.
- 근래에는 암호화 알고리즘이 매우 정교해졌기 때문에, 키를 모르면 암호화된 문서를 해독하는 일이 실질적으로 불가능하다.
- 가상 화폐가 갖춰야 하는 여러 속성 중에서 첫 번째는 바로 복제를 방지할 수 있어야 한다는 점이다. 그리고 복제를 통해서 가상 화폐를 위조하는 것 말고, 한 번 사용한 돈을 다시 사용하는 것을 방지하는 방법도 고려해야만 했다.
- 신용카드를 통해서 이루어지는 소비 행위는, 사람의 소비 패턴을 연구하는 목적은 물론 빅 브라더(Big Brother)가 시민들을 감시하는 목적으로도 쉽게 이용될 수 있다. 하지만 가상 화폐는 이러한 형태의 감시와 추적이 불가능하도록 만들 필요가 있었다.
  - `빅 브라더`: 조지 오웰의 풍자 소설 <1984년>에 등장하는 '빅 브라더'다. 전체주의 사회에서 시민의 일상을 감사하는 권력을 지칭하는 표현이다.
- 가상 화폐는 더 작은 단위의 돈, 즉 거스름돈으로 자유롭게 나뉠 수 있는 속성도 가지고 있어야 했다.
- 가상 화폐의 조건
  - 위조(혹은 복제)할 수 없어야 한다.
  - 한 번 사용한 돈을 같은 사람이 다시 사용하는 것을 방지할 수 있어야 한다.
  - 돈을 사용한 사람의 신원을 추적할 수 없어야 한다.
  - 여러 차례에 걸쳐서 지불된 돈이 같은 사람에게서 나왔는지 여부를 알 수 없어야 한다.
  - 다른 사람에게서 받은 돈을 또 다른 사람에게 지불할 때 사용할 수 있어야 한다.
  - 돈의 크기를 작은 단위로 나눌 수 있어야 한다.
- 이러한 속성 여섯 가지를 모두 만족하는 알고리즘을 작성하는 것은 간단한 일이 아니었다.
- '비트 확인 프로토콜(bit commitment)'란, 사이버 세상에서 서로의 진실성을 확인하기 위한 보증 수표에 해당한다.
- 모든 가상 화폐는 고유한 번호(unique identification)를 가지고 있다. 그리고 가상 화폐의 한구석에는 일정한 개수의 비트로 이루어진 숫자, 즉 비트 확인이 적혀 있다. 비트 확인 정보는 그냥 봤을 때는 특정한 사람의 신원과 연결되지 않지만, 일정한 작업을 거치면 은행에서 가상 화폐를 맨 처음에 인출한 사람의 신원을 드러내도록 하는 방식으로 작성된다.
- 가상 화폐는 '고유 번호', '금액', '비트 확인'이라는 세 가지 중요한 부분으로 이루어져 있다.
- 가상 화폐에 담겨 있는 비트 확인의 값이 1010101010101010101011001이었다면, 상인이 맨 끝자리에 있는 비트 일곱 개를 보여달라고 요구할 수도 있고, 홀수 자리의 비트 값을 보여달라고 요구할 수도 있다(물론 이것은 예일 뿐이다. 실제로는 정해진 알고리즘에 따라서 일정한 수의 비트 확인 값을 요구한다).
- 나중에 상인이 이 돈을 은행에 입금할 때는 노출된 비트 확인 부분을 입금 내역에 반드시 포함시켜야 한다.
- 은행은 상인이 입금하는 가상 화폐로부터 우선 고유 번호와 금액만 읽어들인다. 특별한 경우가 아니라면 비트 확인 부분은 읽지 않는다. 돈을 최초로 인출한 사람의 신원은 비트 확인 부분에 담겨 있으므로, 은행이 고유 번호와 금액만 읽어들이면 익명성이 최대한 보장되는 것이다.
- 고유 번호를 읽었으면 은행이 이제 은행의 데이터베이스에 같은 고유 번호가 이미 저장되어 있는지를 확인한다. 고유 번호는 각 가상 화폐마다 다르므로, 데이터베이스에 고유 번호가 없어야 정상이다.
- 만약 데이터베이스에서 같은 고유 번호가 발견되면 문제가 발생한 것이다. 소비자나 상인 중 누군가 같은 돈을 두 번 이용한 것이기 때문이다.
- 비트코인은 기술보다 이데올로기라는 측면에서 더 많은 화제를 낳았다. P2P 방식을 채택한 것이 사람들을 놀라게 만든 것이다.
- 전통적으로 화폐는 중앙은행과 정부가 관리하는 대상이라고 인식되어 왔다. 인플레이션을 조절하거나, 공적기금을 조성하는 것처럼, '국가'의 업무를 수행하기 위해 화폐를 발행하는 권리가 중앙 조직에 귀속되는 것을 당연하게 여긴 것이다. 하지만 P2P라는 프로토콜은 기본적으로 '중앙'의 개입을 상정하지 않는다.
- 비트코인의 거래는 철저하게 암호화 기법에 의존한다. A라는 사람이 B라는 사람에게 일정한 금액의 비트코인을 지불한다고 하자. A가 사용하는 비트코인 지갑(컴퓨터나 스마트폰에 설치된 소프트웨어를 의미한다)을 이용해서 비트코인의 거래 내역을 담은 블록체인(blockchain)이라는 것을 만들고, 자신의 개인 키를 이용해서 암호화한다. A의 공개 키는 누구나 손에 넣을 수 있으므로 공개 키를 이용하면 A가 암호화한 블록체인의 내용을 들여다볼 수 있다.
- 블록체인이라는 사슬의 길이는 거래가 일어날수록 점점 길어진다.
- 비트코인은 중앙은행이나 정부가 발행하는 것이 아니기 때문에, 자발적인 사용자 네트워크에서 정성껏 '채굴'되어야 한다.
- 누구나 채굴을 할 수 있지만, 채굴에 성공하는 사람은 소수다.
- 금과 마찬가지로 희소가치를 통해서 교환 가치를 창출한다.
- 비트코인을 채굴하는 방법은, 암호학과 통계를 기반으로 한다. 예를 들어서 설명하면 이렇다. 주머니 안에 1부터 1,000까지 숫자가 적힌 공이 있다고 하자. 눈을 감고 공을 하나 꺼내서 번호를 확인한다. 만약 꺼낸 공에 적힌 수가 50 이상이면 다시 주머니에 넣고 흔든다. 50보다 작으면 비트코인 하나를 획득하게 된다. 이게 전부다.
- 프로그래머 스스로 남들이 읽기에 편하고 깔끔한 프로그램을 작성하려는 의지가 없으면, 코딩 관습은 별로 의미가 없다.

<br>

> "아래 문장은 참이다."
>
> "위 문장은 거짓이다."

<br>

- '소설처럼 읽히는 프로그램'이란 '보통 수준의 프로그래머'가 읽었을 때 의미가 한눈에 이해되는 프로그램을 뜻한다.
- 객체는 데이터와 함수를 동시에 포함하고 있는 컴퓨터 프로그래밍의 한 단위이다.
- 프로그래머는 객체를 이용해서 복잡한 소프트웨어의 구조와 골격을 훨씬 단순하게 만들 수 있다.
- 객체가 있기 전에는 프로그램의 구조가 핵심적인 알고리즘 하나를 중심으로 작성됐다. 필요할 때마다 핵심 알고리즘이 다른 곳에 정의되어 있는 함수를 호출하는 방식으로 프로그램이 진행됐다. 호출된 함수는 자기가 담고 있는 알고리즘을 실행한 다음, 통제권을 다시 핵심 알고리즘에 돌려줬다. 이러한 방식은 핵심 알고리즘에 많은 절차와 기능이 집중된다는 점에서 일종의 '중앙집권제'적인 시스템이다. 프로그램 전체의 규모가 커지고, 다뤄야 하는 논리가 복잡해지면 그에 따라서 중앙집권적인 핵심 알고리즘도 복잡해질 수밖에 없는 구조다. 그러나 객체의 등장은 모든 것을 바꿔놨다. 프로그래머는 함수보다 상위개념인 객체를 만들어서 중앙 정부(핵심 알고리즘)의 업무를 지방(객체)으로 대폭 이양할 수 있게 됐다.
- 예전에는 핵심 알고리즘이 eat()과 fly() 함수를 언제든지 호출할 수 있었지만, 객체가 사용된 다음부터는 eat()을 호출하고 싶으면 Man 객체에 부탁하고, fly()를 호출하고 싶으면 Airplane 객체에 부탁해야 하는 상황이 됐다. 이와 같은 방식을 통해서 프로그램의 구조는 엄청나게 간결해질 수 있었다.
- 프로그래머는 대부분 월급을 받는 샐러리맨이지만, 심장 한구석이 해커 정신에 맞닿아 있는 사람들이다.
- 아키텍처를 결정하기 위해서는 소프트웨어의 목적과 수명주기(life cycle)에 대한 깊은 이해가 필수다. 사용자가 원하는 기능을 어떻게 구현할지를 신중하게 고려해야 하고, 그 소프트웨어가 장차 어떻게 자라갈 것인지에 대해서도 충분히 생각해야 한다.
- 소프트웨어가 성장하여 다루는 데이터의 양이 많아지면, 그에 반비례하여 성능이 저하된다. 만약 소프트웨어를 여러 곳으로 분산시켜서 동시에 실행할 수 있으면 성능의 저하를 막을 수 있을 것이다. 이런 방법을 보통 소프트웨어의 확장성(scalability)이라고 한다.
- 새로운 프로그래밍 언어나 소프트웨어 제품을 충분히 이해하지 못한 상태에서는 좋은 설계나 코딩이 나올 수 없다.
- 설계자 자신도 핵심적인 부분을 개발하는 것이 보통이다. 설계자는 기술적인 능력만이 아니라, 다른 프로그래머들을 통솔할 수 있는 리더십과, 정확한 의사소통 기술을 반드시 갖추고 있어야 한다.
- 설계자는 프로그래밍 능력 되에도 복잡하게 얽히고 설킨 소프트웨어 컴포넌트나 객체들 사이의 관계를 전체적으로 조망할 힘이 있어야 한다. 현재의 기술 흐름을 정확하게 읽고 있는 것은 물론, 미래의 기술이 나아가는 방향도 직관적으로 감지할 수 있어야 한다.
- 끊임없이 공부하고, 토론하고, 부딪히는 과정을 온몸으로 즐기는 뜨거운 열정이 없으면 설계자가 되기 어렵다.
- 문제는 "버그가 아예 없는 프로그램을 만들 수 있는가"가 아니라, "버그가 발생했을 때 얼마나 신속하고 철저하게 수정할 수 있는가"다. 그리고 이러한 문제는 능력의 문제가 아니라, 성의와 자세의 문제로 귀착되는 경우가 많다.
- 프로그래머들이 즐겨 하는 질문이 하나 있다. "네가 만든 소프트웨어가 조종하는 비행기에 올라탈 수 있는가?"

<br>