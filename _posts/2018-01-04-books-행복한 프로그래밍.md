---
layout: post
title: "행복한 프로그래밍"
categories: dev
tags: books
---

###### 임백준 저

<br>

- 내가 엔터키를 두드렸을 때 인터넷 익스플로러는 문자로 입력된 웹 사이트 주소를 근처에 있는 DNS 서버로 보내서 숫자로 된 주소 값(IP 주소)을 알아냈을 것이다. 다음에는 입력된 정보를 HTTP에 맞게 재구성하여 운영체제에 넘겨주었을 것이다. 네트워크를 담당하는 프로그램은 다시 그 정보를 패킷이라는 작은 조각으로 나눠서 컴퓨터에 연결된 랜선을 통해 컴퓨터의 바깥으로 내보냈을 것이다. 그러면 회사 내부의 네트워크와 바깥의 네트워크를 구분하는 관문(gateway) 역할을 하는 프록시(proxy) 서버의 주소를 알아낸 다음 그 패킷을 해당 웹 서버로 보냈을 것이다. 아직 더 남았다. 웹 서버가 실행되고 있는 컴퓨터의 운영체제인 유닉스 시스템은 자기에게 전달된 패킷을 모두 모아서 원래의 HTTP에 맞는 정보로 재구성한 다음 그 것을 아파치(Apache)라는 웹 서버로 전달했을 것이다. 아파치 웹 서버는 다시 그 정보를 프로그램에 전달했을 것이고, 프로그램은 그렇게 전달된 정보를 이용해서 HTML 문서를 만들고, 그것을 다시 아파치에게 돌려주었을 것이다. 이렇게 아파치에 전달된 HTML은 유닉스 시스템에 전달되어 작은 패킷들로 나뉘고, 그것이 컴퓨터의 시스템에 전달되어 원래의 HTML 문서로 재구성된 다음, 마침내 인터넷 익스플로러 화면 위에 나타나게 된 것이다.
- 현실 세계의 물질이 원자로 이루어져 있듯이, **사이버 세상의 물질은 비트로 이루어져 있다.**
- 복잡하고 정교한 논리의 체계가 단지 1과 0이라는 비트 두 개에서 출발하는 것과 마찬가지로, 강력한 연산 능력을 자랑하는 현대 컴퓨터의 육신은 불 대수를 구현하고 있는 논리 게이트에서 출발한다.
- 논리 게이트에는 'AND' 게이트, 'OR' 게이트, 'XOR' 게이트, 그리고 'NOT' 게이트 등이 존재하는데, **아무리 복잡하고 정교한 연산을 수행하는 반도체 칩도 모두 이러한 단순한 논리 게이트에서 시작한다**.
- 컴퓨터 시스템의 발전에 혁혁한 공을 세운 불의 이름을 잊지 않고 기억해두기 위해서 참(true)과 거짓(false) 중에서 하나를 값으로 갖는 자료형을 `불리언(boolean)` 혹은 `불(bool)`이라고 부르고 있다.
- 10진수를 2진수로 변환하는 알고리즘
  1. 주어진 수를 2로 나눈다. 만약 나눠떨어지면 땅에 1을 적고, 아니면 0을 적는다.
  2. 나누기 결과, 땅에 1을 적었으면 남은 수를 다시 2로 나눈다. 나눠떨어지면 땅에 적힌 수의 오른쪽에 1을 적고, 아니면 0을 적는다.
  3. 나누기 결과, 땅에 0을 적었으면 남은 수에 1을 더한 다음 2로 나눈다. 나눠떨어지면 땅에 적힌 수의 오른쪽에 1을 적고, 아니면 0을 적는다.
  4. 남아 있는 수가 0이 될 때까지 이 과정을 반복한다.
- 2진수의 원리는 비트의 법칙을 구성하는 기본적인 원리이다.

<br>

- **10진수 / 2진수 / 16진수**

> 0 / 0000 / 0
>
> 1 / 0001 / 1
>
> 2 / 0010 / 2
>
> 3 / 0011 / 3
>
> 4 / 0100 / 4
>
> 5 / 0101 / 5
>
> 6 / 0110 / 6
>
> 7 / 0111 / 7
>
> 8 / 1000 / 8
>
> 9 / 1001 / 9
>
> 10 / 1010 / A
>
> 11 / 1011 / B
>
> 12 / 1100 / C
>
> 13 / 1101 / D
>
> 14 / 1110 / E
>
> 15 / 1111 / F

<br>

- 비트의 법칙을 이해하기 위한 첫걸음은 2진수끼리 더하고 빼는 연산을 자유자재로 할 수 있는 기본을 닦는 일이다. 기본을 익히고 난 다음에는 곱하기, 나누기, 오버플로(overflow), 1의 보수(1's complement), 2의 보수(2's complement)와 같이 약간 고급스러운 개념을 공부한다.
- 2진수와 16진수 사이에 존재하는 재미있는 특성 하나는, 네 자리로 이루어진 2진수 수가 항상 한 자리의 16진수 수에 대응한다는 사실이다. 그렇기 때문에 기다란 2진수는 종종 16진수를 이용해서 간단하게 표시하기도 한다. 2진수 숫자로 가득 찬 컴퓨터 메모리의 내부를 흔히 2진수가 아니라 16진수로 나타내는 것이 대표적인 예다.
- '1101110001010010'과 같이 비트 16개로 이루어진 2진수를 16진수로 표현한다면, 2진수를 네 자리씩 끊었을 때 '1101'이 D에 해당하고, '1100'이 C에 해당하고, '0101'이 5에 해당하고, 마지막 '0010'이 2에 해당하므로, 'DC52'처럼 훨씬 간단하게 표기할 수 있다.
- `2^10 = 10^3`. **2^10은 1,024고, 10^3은 1,000이므로, 이 등식은 수학적으로 사실이 아니다.** 그러나 커다란 수를 많이 다루는 프로그래머들은 2진수와 10진수 사이의 복잡한 계산을 피하려고 이 공식을 즐겨 사용한다.

<br>

- 위 공식이 사용되는 예

> 한 번에 비트 32개로 이루어진 메모리 주소 공간을 다루는 컴퓨터를 보통 32비트 컴퓨터라고 부른다. 그런데 사람들은 비트 32개로 이루어진 2진수로 나타낼 수 있는 최대값이 '40억'이기 때문에 메모리를 최대 4GB까지만 지원할 수 있다고 말한다. 그러나 이것은 사실 정확한 표현이 아니다. 비트 한 개로 나타낼 수 있는 최대값은 1이고, 비트 두 개로 나타낼 수 있는 최대값은 11(10진수로 3)이며, 비트 세 개로 나타낼 수 있는 최대값은 111(10진수로 7)이다. 이러한 결과를 보면 비트의 수와, 그것으로 나타낼 수 있는 2진수의 최대값 사이에는 일정한 함수 관계가 존재한다는 사실을 알 수 있다. 즉, 비트의 수가 n이라고 했을 때, 그 수만큼의 비트를 이용해서 나타낼 수 있는 2진수의 최대값은 2^n-1이다. 그렇다고 한다면 비트 32개로 이루어진 2진수로 나타낼 수 있는 최대값은 다음과 같다.
>
> `11111111111111111111111111111111 = 2^32 - 1 = 4,294,967,295`
>
> 다시 말해서, **4GB라는 표현은 40억을 의미하기 때문에 실제로는 뒤에 붙어 있는 294, 967,295라는 엄청난 수를 생략하고 있는 것이다.**

<br>

- 256M(메가)는 실제로 2의 몇 승을 의미하는 숫자일까?

> 256M = 256 x 10^6 = 2^8 x 10^6 = 2^8 x (10^3)^2 = 2^8 x (2^10)^2 = 2^8 x 2^20 = 2^28
>
> 그런데 2^28을 실제로 계산한 값은 268,435,456이므로 256,000,000과 비교하면 무려 12,435,456만큼 더 크다. 여기에서도 마찬가지로 이상한 공식 덕택에 적어도 12MB정도는 허공에 날려버리는 것이다.

<br>

- 비트의 법칙에 익숙해져서 2진수, 8진수, 16진수와 같은 수의 체계 사이를 자유자재로 돌아다니면서 연산을 수행할 수 있게 되면 최소한 밥 짓고 빨래하는 일은 졸업하게 된다.
- 비트의 법칙을 이해하는 것은 어디까지나 프로그래밍의 아름다움을 감상하는 데 필요한 준비 작업이지, 그 자체가 목적인 시대는 지났다.
- 해바라기 씨앗의 배열을 닮은 피보나치 수열은 매우 아름답지만, 그것을 컴퓨터 프로그램으로 옮기는 것이 별로 어려운 일이 아니라는 사실은 나중에야 알게 됐다.
- 프로그래밍을 먹고 살기 위해서 어쩔 수 없이 하는 소외된 노동으로 만드는가, 아니면 자기를 실현하는 해방된 노동으로 만드는가는 자신에게 달려 있다.
- 프로그래머는 프로그래밍 언어를 익히고, 수학적 추론을 학습하고, 알고리즘을 작성하고, 프로그램의 속도를 분석한다.
- 피보나치 수열은 두 개의 1로 시작해서 앞의 두 수를 더한 수가 현재의 수가 되는 방식으로 진행된다.
  - 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...
- 피보나치 수열을 수학 공식으로 나타내면 다음과 같다.
  - F(n) = 1 (n <= 2)
  - F(n) = F(n-1) + F(n-2) (n >2)
- 피보나치 수열은 n의 값이 증가할수록 끝의 두 수 사이의 비율이 점점 황금비인 1.618..에 수렴하는 것으로 알려져 있다. 나무가 가지를 뻗는 모습, 소라나 고동의 집이 회오리 모양의 원을 그리며 가운데로 수렴하는 모습, 백화, 붓꽃, 채송화, 데이지와 같은 꽃잎의 개수, 은하계의 나선형 모양과 같은 자연 속의 사물은 물론, 담배갑의 가로세로 비율이나 배꼽을 중심으로 사람의 상체와 하체도 황금비를 이룬다.
- 프로그래밍 실력이 일정 수준에 도달한 사람은 대개 한 번쯤은 커누스 교수의 <컴퓨터 프로그래밍의 기술(The Art of Computer Programming)>을 찾는다.
- 프로그램을 처음 시작하는 사람이 주로 관심을 갖는 부분은 특정한 프로그래밍 언어의 문법과 API인 경우가 많지만, **프로그래밍의 본질은 프로그래밍 언어에 담겨 있는 것이 아니라 수학적 논리 체계, 즉 알고리즘에 담겨 있다.**
- `스레드(thread)`: 간섭을 받지 않고 독립적으로 수행되는 프로그램의 기본 단위
- 한 줄 서기 알고리즘은 `큐(Queue)`라고 불리는 자료구조가 사용하는 'FIFO(First-In-First-Out, 선입선출)' 알고리즘을 구현한 예라고 볼 수 있다.
- 접시가 쌓였다가 닦이는 과정을 생각해보면, 맨 나중에 들어와서 맨 위에 놓인 접시가 가장 먼저 닦인다는 사실을 쉽게 발견할 수 있다. 이러한 알고리즘을 구현하고 있는 자료구조를 `스택(Stack)`이라고 부른다.
- 단어를 찾을 때 단어를 지나쳤으면 앞쪽으로 페이지를 넘기고, 그렇지 않으면 뒤쪽으로 페이지를 넘길 것이다. 이러한 검색 방법은 `이진 검색(Binary Search)`이다.
- 프로그래밍이라는 일은 알고리즘을 만들어내는 과정과, 알고리즘을 프로그램으로 바꿔주는 두 부분으로 이뤄진다고 볼 수 있다.
- 프로그래밍 언어는, 비트의 법칙에 대한 깊은 이해와 언어학에 대한 통찰을 바탕으로 만들어지는 인공의 언어이다.
- 컴퓨터는 프로그래밍 언어로 작성된 프로그램을 있는 그대로 읽고 이해하지 못한다. 그 대신 프로그램 코드는 반드시 `컴파일러(Compiler)`라는 소프트웨어를 통해서 컴퓨터가 이해할 수 있는 언어인 이진 코드(Binary code)로 번역되어야 한다.
- 2진수 코드는 컴퓨터를 위한 언어이고, 프로그래밍 언어는 사람을 위한 언어이다.
- 프로그래머는 프로그래밍 언어를 이용해서 프로그램 코드를 작성하고, 컴파일러는 다시 프로그램 코드를 2진수 코드로 번역한다.
- "컴파일러를 작성하는 것은 프로그래밍 언어, 컴퓨터 아키텍처, 언어 이론, 알고리즘, 그리고 소프트웨어 공학의 문제로 확장된다." \- <Compilers: Principles, Techniques>
- 프로그래밍 언어의 의미를 해석하고, 문법을 검사하고, 코드를 최적화하는 컴파일러의 작업을 이해하려면 여러 주제를 학습할 필요가 있다.
- 컴파일러에서는 인식할 수 있는 단위 하나를 보통 `토큰(token)`이라고 한다.
- 컴파일러가 프로그램 코드를 해석하는 과정은, 주어진 입력(프로그램 코드)을 읽어 들여서 키워드와 일치하는지 혹은 언어의 문법에 부합하는지 확인하는 과정으루 이루어져 있다.
- 프로그램의 덩치가 커지고 복잡해지면, 논리상의 허점들이 프로그래머는 물론 컴파일러의 눈에도 쉽게 보이지 않게 된다.
- 알고리즘 하나하나는 치밀하고 완벽하게 작성된 것처럼 보이지만, 그러한 알고리즘이 모여서 만들어진 소프트웨어를 보면 전혀 예상하지 않았던 결과가 나타나기도 한다.
- Java, C#, Ruby, Python, Go 언어, 스칼라, JavaScript와 같은 일반적인 프로그래밍 언어를 비롯해서 리스프(LISP), 프롤로그(Prolog), 스킴(Scheme)과 같이 인공 지능(Artificial Intelligence) 분야에서 사용되는 언어들은 '고급(high-level) 언어'라고 하여 주로 사람이 읽기 편하도록 고안된 언어에 해당하지만, 특정한 컴퓨터 칩(CPU 혹은 마이크로프로세서)을 위해서 고안된 '저급(low-level) 언어'인 어셈블리(Assembly) 언어에서는 칩마다 서로 다른 언어를 가지고 있기 때문에 칩의 종류만큼이나 많은 언어가 존재한다.
- 내공이 부족한 프로그래머가 작성한 알고리즘은 대개 필요 이상으로 복잡하고 최적화도 고려되어 있지 않다.
- 알고리즘의 효율성에 관한 신중한 고민이 없이 작성된 프로그램은 실전 프로그래밍에서 심각한 문제를 일으킨다.
  - 프로그램의 성능을 저하시킨다.
  - 버그가 발생하도록 만든다.
- 프로그램 성능이란 대개 프로그램이 실행되는 속도를 의미한다.
- 실제 속도는 컴퓨터의 CPU 성능이나 메모리 용량과 같은 가변 조건에 의해서 달라지기 때문에 알고리즘의 속도를 분석할 때 보편적으로 이용할 수 없다. 그래서 알고리즘을 분석할 때에는 절대적인 값을 갖는 이론적인 속도가 더 중요하다.
- 이론적인 알고리즘 분석에서는 가상의 수 n을 수학적으로 좀 더 명확하게 정의하기 위해서 극한(lim)이나 빅오(Big-O), 스몰오(Small-O) 등과 같은 수학 함수를 사용한다.
- `시간`과 `공간`이라는 우주의 두 기본 축은 원자의 세계에서뿐만 아니라, 비트의 세계에서도 서로 직교하고 있다. 비트의 세계에 존재하는 알고리즘이 시간을 절약하기 위해서는 더 많은 공간이 필요하고, 공간을 절약하기 위해서는 더 긴 시간이 필요하다는 사실은 상식으로 통한다. 특정한 알고리즘이 더 빠르게 수행되도록 만들기 위해서는 일반적으로 더 많은 메모리 공간을 사용해야 하고, 그 반대로 메모리 공간을 최소로 사용하게 만들기 위해서는 알고리즘이 수행되는 속도를 일정 정도 희생해야 한다는 말이다.
- 부분적인 알고리즘이 아무리 효율적으로 작성되어 있더라도, 소프트웨어의 전체적인 설계가 엉망이거나, 프로그래밍 언어의 고유한 특성을 제대로 살리지 못한다면, 좋은 품질의 소프트웨어가 되기 어렵다.
- 성장하고자 하는 프로그래머는 수학적 추론이나 논리 능력을 키우는 것 외에도, 자신이 선택한 프로그래밍 언어의 속성과 기능들을 정확하게 파악하여, 그것을 자신이 고안한 알고리즘을 구현하는 데 정확하게 적용할 수 있도록 해야 한다.
- 빅데이터, 분산 컴퓨팅, 동시성 프로그래밍이라는 시대적 요청에 부응하기 위해서 함수형 프로그래밍 언어가 주목받는 요즘, JVM에서 클로저 언어와 더불어 자바의 대안 언어로 인식되는 스칼라는 기본적으로 함수 패러다임을 사용하는 언어이다. 하지만 자바를 이용하던 다수의 개발자들은 스칼라 언어를 사용해서 자바 코드를 작성한다.
- C를 사용하던 개발자가 자바를 접하면 객체 지향이라는 방법론, 자바가 해결하고자 했던 문제의 본질을 고민할 필요가 있다. 마찬가지로 자바를 사용하던 개발자가 스칼라를 접하면 함수 패러다임이라는 방법론, 그리고 스칼라가 해결하고자 했던 문제의 본질을 고민할 필요가 있다.
- 프로그래밍 언어를 익히기 위한 가장 훌륭한 방법은, 그것을 이용해서 실제 프로젝트를 수행함으로써 경험을 쌓는 것이다.
- C 언어는 프로그래머가 쉽게 이해할 수 있는 고급 언어 문법 구조를 지니고 있으면서도, CPU와 메모리라고 하는 비트의 세계 깊숙한 곳까지 들어갈 수 있도록 해주기 때문에, 엄청난 주목과 찬사를 받으면서 단숨에 1970년대와 1980년대를 관통하는 최고의 프로그래밍 언어로 등극했다.
- C 언어는 객체 지향 언어보다 절차 중심(procedure-oriented)의 언어라는 한계를 가지고 있다.
- 객체 지향 언어가 절차 중심의 언어보다 더 낫다고 볼 수는 없지만, 절차 중심의 언어가 해결하기 어려운 문제를 객체 지향 언어로 풀 수 있다는 점에서 그 둘의 차이는 분명히 존재한다.
- 절차적인 언어의 핵심은, 입력을 보내면 잠시 후에 출력 결과를 되돌려주는 함수라고 볼 수 있다.
- 프로그래밍을 익힌다고 하는 것은 패턴과 기법을 자기 것으로 만들어서, 어려운 문제를 풀 때 적절하게 응용할 수 있는 능력을 키우는 것이다.
- 복잡성 이론(Complexity Theory) 분야의 연구는 구체적인 알고리즘 개발과 직접적인 상관은 없지만, 어떤 문제가 쉽게 풀 수 있는 문제고, 어떤 문제가 쉽게 풀 수 없는 문제인지를 구별해준다.
- 속도를 분석할 때 n이라는 변수에 붙은 지수가 1이나 2처럼 미리 정해진 값, 즉 상수로 표현된다면 그 알고리즘을 쉬운 문제라고 간주한다.
- 지수의 값이 아무리 크다고 해도 그것이 미리 정해진 상수값이라면, 그 알고리즘은 컴퓨터가 적당한 시간 안에 계산해낼 수 있는 쉬운 알고리즘에 해당한다.
- 변수 위에 붙은 지수가 미리 정해진 상수인 수학 공식을 다항식이라고 부른다.
  - example) 2n^3 x n^2 - 3
- 복잡성 이론에서 다항식의 반대말은 '지수 함수'다. 지수 함수의 반대말은 로그 함수다.
- 지수 변수란, 변수 위에 붙은 지수가 미리 정해져 있는 상수값이 아니라, 그 자신도 변수로 표현되는 함수를 의미한다.
- 지수 함수의 예
  - 2^n
  - 2n^n-1 + 2^n
- 지수 함수의 특징은 n이 조금만 커지면 함수 전체의 값이 기하급수적으로 커진다는 사실이다.
- 지수 함수들은 n값이 커짐에 따라, 함수의 결과가 엄청나게 빠르게 증가하여 컴퓨터조차 쉽게 계산할 수 없다는 이유로, 이를 `어려운 문제`라고 한다. 즉, 알고리즘의 속도가 다항식이 아니라 지수 함수로 표현되면, 그것은 어려운 알고리즘인 것이다.
- 복잡성 이론에서는 알고리즘의 속도가 다항식으로 표현되는 문제들을 묶어서 'P'라 하고, 다항식으로 표현할 수 있는지가 알려지지 않은 문제들을 묶어서 'NP'라고 한다. 여기서 P는 polynomia(다항식)의 머리글자고, NP는 nondeterministic polynomial(비결정성 다항식)의 머리글자다. 이때 NP가 non-polynomial(비다항식)을 뜻하지 않는다는 점에 유의할 필요가 있다.
- 'NP-hard'라고 불리는 문제들은 모든 경우의 수를 전부 확인해보는 방법 이외에는 정확한 답을 구하는 뾰족한 수가 없는 문제를 뜻한다.
- 어떤 문제가 NP에 속하면서, 즉 다항식으로 표현할 수 있는지가 알려져 있지 않았으면서, 동시에 NP-hard에 속한다면 그 문제는 'NP 완전(NP complete) 문제'라고 한다. 비밀번호를 깨뜨리기 위한 해킹 과정도 NP 완전 문제에 속한다고 볼 수 있다.
- 비밀번호를 깨는 과정을 이해하려면 우선, ASCII(아스키) 문자 집합이라는 것을 알아야 한다.
- ASCII(American Standard Code for Information Interchange)란, 키보드로 입력하는 문자나 숫자, 혹은 특수 문자 128개를 일정한 숫자 값에 대응시킨 표준 테이블을 의미한다.
- 비밀번호는 결국 키보드로 입력할 수 있는 문자 128개 중에서 선택된 문자 몇 개로 이루어진다.
- 존 더 리퍼(John the Ripper)나 아울(Owl)과 같은 유명한 비밀번호 해킹 프로그램은 바로 사전식 공격(dictionary attack)에 기초를 두고 있다.
- 사전식 공격이란, 사전에 수록된 단어, 약자, 시사 용어, 유행어, 혹은 사람들이 비밀번호를 만들 때 흔히 사용하는 전형적인 패턴을 분석해서, 커다란 데이터베이스를 구축한 다음 비밀번호를 깨뜨리는 데 활용하는 것이다.
- 공개 키(public key)와 개인 키(private key)는 인터넷 뱅킹이 고객의 정보를 보호하기 위해서 사용하는 암호화 방식의 근간을 이루는 원리이다.
- 인터넷은 직행버스가 아니라 완행버스다. 즉, 내가 보낸 정보는 PC에서 은행 웹 서버로 곧바로 전달되지 않고, 중간에 많은 다른 서버를 거쳐서 전달된다. 그렇기 때문에 인터넷을 통해서 민감한 정보를 보낼 때는 반드시 암호화한 다음에 보내야 한다. 그리고 암호화하려면 반드시 키(key)가 있어야 한다.
- 암호화(encryption)와 해독(decryption, 복호화)을 동일한 키로 수행하는 기법을 `대칭형 암호화(symmetric encryption)`라고 하고, 공개 키와 개인 키를 이용해서 수행하는 기법은 `비대칭형 암호화(asymmetric encryption)`라고 한다.
- 비대칭형 암호화를 수학적으로 정의
  - 키 생성 함수(key generation function)에 의해서 공개 키인 K와 개인 키인 K^-1이 생성되었다고 하자. 암호화 알고리즘은 E라고 부르고, 해독 알고리즘은 D라고 부르자. 보내려는 정보, 즉 암호화되기 전의 평범한 텍스트(plain text, 평문)는 P라고 부른다. 암호화 알고리즘 E와 공개 키 K를 이용해서 P를 암호화한 문서는 E밑K(P)라고 표기한다. 이것은 암호화된 문서를 의미한다. 만약 해독 알고리즘 D와 개인 키 K^-1를 이용해서 암호화한 문서 E밑K(P)를 해독하면 그 결과가 원래 문서인 P가 되어야 한다. 이것을 수식으로 표현하면 다음과 같다.
  - D밑K-1(E밑K(P)) = P
  - 이런 조건을 `가역성(invertability)`이라고 한다.
- 근래에는 암호화 알고리즘이 매우 정교해졌기 때문에, 키를 모르면 암호화된 문서를 해독하는 일이 실질적으로 불가능하다.
- 가상 화폐가 갖춰야 하는 여러 속성 중에서 첫 번째는 바로 복제를 방지할 수 있어야 한다는 점이다. 그리고 복제를 통해서 가상 화폐를 위조하는 것 말고, 한 번 사용한 돈을 다시 사용하는 것을 방지하는 방법도 고려해야만 했다.
- 신용카드를 통해서 이루어지는 소비 행위는, 사람의 소비 패턴을 연구하는 목적은 물론 빅 브라더(Big Brother)가 시민들을 감시하는 목적으로도 쉽게 이용될 수 있다. 하지만 가상 화폐는 이러한 형태의 감시와 추적이 불가능하도록 만들 필요가 있었다.
  - `빅 브라더`: 조지 오웰의 풍자 소설 <1984년>에 등장하는 '빅 브라더'다. 전체주의 사회에서 시민의 일상을 감사하는 권력을 지칭하는 표현이다.
- 가상 화폐는 더 작은 단위의 돈, 즉 거스름돈으로 자유롭게 나뉠 수 있는 속성도 가지고 있어야 했다.
- 가상 화폐의 조건
  - 위조(혹은 복제)할 수 없어야 한다.
  - 한 번 사용한 돈을 같은 사람이 다시 사용하는 것을 방지할 수 있어야 한다.
  - 돈을 사용한 사람의 신원을 추적할 수 없어야 한다.
  - 여러 차례에 걸쳐서 지불된 돈이 같은 사람에게서 나왔는지 여부를 알 수 없어야 한다.
  - 다른 사람에게서 받은 돈을 또 다른 사람에게 지불할 때 사용할 수 있어야 한다.
  - 돈의 크기를 작은 단위로 나눌 수 있어야 한다.
- 이러한 속성 여섯 가지를 모두 만족하는 알고리즘을 작성하는 것은 간단한 일이 아니었다.
- '비트 확인 프로토콜(bit commitment)'란, 사이버 세상에서 서로의 진실성을 확인하기 위한 보증 수표에 해당한다.
- 모든 가상 화폐는 고유한 번호(unique identification)를 가지고 있다. 그리고 가상 화폐의 한구석에는 일정한 개수의 비트로 이루어진 숫자, 즉 비트 확인이 적혀 있다. 비트 확인 정보는 그냥 봤을 때는 특정한 사람의 신원과 연결되지 않지만, 일정한 작업을 거치면 은행에서 가상 화폐를 맨 처음에 인출한 사람의 신원을 드러내도록 하는 방식으로 작성된다.
- keep going
